{
    "docs": [
        {
            "location": "/", 
            "text": "RNG.jl Documentation\n\n\nRNG.jl\n is a collection of Random Number Generators for the Julia language.\n\n\nThere are several kinds of RNG families in this package, provided as submodules.\n\n\nThe examples and detailed descriptions of each RNG can be found on the Manual pages.\n\n\n\n\nManual Outline\n\n\n\n\nBases\n\n\nInstallation\n\n\nInterface\n\n\nEmpirical Statistical Testing\n\n\nConversion to Float\n\n\n\n\n\n\nBenchmark\n\n\nSpeed Test\n\n\nBig Crush Test\n\n\n\n\n\n\nPCG Family\n\n\nPCG Type\n\n\nPCG Method Type\n\n\nInterface and Examples\n\n\n\n\n\n\nMersenne Twisters\n\n\nExamples\n\n\n\n\n\n\nRandom123 Family\n\n\nRandom123 RNGs\n\n\nExamples\n\n\n\n\n\n\nXorshift Family\n\n\nExamples\n\n\n\n\n\n\n\n\n\n\nLibrary Outline\n\n\n\n\nRNG\n\n\nIndex\n\n\nPublic\n\n\nInternal\n\n\n\n\n\n\nPCG\n\n\nIndex\n\n\nPublic\n\n\nInternal\n\n\n\n\n\n\nMersenneTwisters\n\n\nIndex\n\n\nPublic\n\n\nInternal\n\n\n\n\n\n\nRandom123\n\n\nIndex\n\n\nPublic\n\n\nInternal\n\n\n\n\n\n\nXorshifts\n\n\nIndex\n\n\nPublic\n\n\nInternal", 
            "title": "Home"
        }, 
        {
            "location": "/#rngjl-documentation", 
            "text": "RNG.jl  is a collection of Random Number Generators for the Julia language.  There are several kinds of RNG families in this package, provided as submodules.  The examples and detailed descriptions of each RNG can be found on the Manual pages.", 
            "title": "RNG.jl Documentation"
        }, 
        {
            "location": "/#manual-outline", 
            "text": "Bases  Installation  Interface  Empirical Statistical Testing  Conversion to Float    Benchmark  Speed Test  Big Crush Test    PCG Family  PCG Type  PCG Method Type  Interface and Examples    Mersenne Twisters  Examples    Random123 Family  Random123 RNGs  Examples    Xorshift Family  Examples", 
            "title": "Manual Outline"
        }, 
        {
            "location": "/#library-outline", 
            "text": "RNG  Index  Public  Internal    PCG  Index  Public  Internal    MersenneTwisters  Index  Public  Internal    Random123  Index  Public  Internal    Xorshifts  Index  Public  Internal", 
            "title": "Library Outline"
        }, 
        {
            "location": "/man/bases/", 
            "text": "Bases\n\n\nThis page describes basic concepts and fundanmental knowledge of \nRNG.jl\n.\n\n\n\n\nNote\n\n\nUnless otherwise specified, all the random number generators in this package are \npseudorandom\n number generators (or \ndeterministic\n random bit generator), which means they only provide numbers whose properties approximate the properties of \ntruly random\n numbers. Always, especially in secure-sensitive cases, keep in mind that they do not gaurantee a totally random performance.\n\n\n\n\n\n\nInstallation\n\n\nThis package is currently not registered, so you have to directly clone it for installation:\n\n\njulia\n \nPkg\n.\nclone\n(\nhttps://github.com/sunoru/RNG.jl.git\n)\n\n\n\n\n\n\nAnd build the dependencies:\n\n\njulia\n \nPkg\n.\nbuild\n(\nRNG\n)\n\n\n\n\n\n\nIt is recommended to run the test suites before using the package:\n\n\njulia\n \nPkg\n.\ntest\n(\nRNG\n)\n\n\n\n\n\n\n\n\nInterface\n\n\nFirst of all, to use a RNG from this package, you can import \nRNG.jl\n and use RNG by declare its submodule's name, or directly import the submodule. Then you can create a random number generator of certain type. For example:\n\n\njulia\n \nusing\n \nRNG\n\n\njulia\n \nr\n \n=\n \nXorshifts\n.\nXorshift1024Plus\n()\n\n\n\n\n\n\nor\n\n\njulia\n \nusing\n \nRNG\n.\nXorshifts\n\n\njulia\n \nr\n \n=\n \nXorshift1024Plus\n()\n\n\n\n\n\n\nThe submodules have some API in common and a few differently.\n\n\nAll the Random Number Generators (RNGs) are child types of \nAbstractRNG{T}\n, which is a child type of \nBase.Random.AbstractRNG\n and replaces it. (\nBase.Random\n may be refactored sometime, anyway.) The type parameter \nT\n indicates the original output type of a RNG, and it is usually a child type of \nUnsigned\n, such as \nUInt64\n, \nUInt32\n, etc. Users can change the output type of a certain RNG type by use a wrapped type: \nWrappedRNG\n.\n\n\nConsistent to what \nBase.Random\n does, there are generic functions:\n\n\n\n\nsrand(::AbstractRNG{T}[, seed])\n   initializes a RNG by one or a sequence of numbers (called \nseed\n). The output sequences by two RNGs of   the same type should be the same if they are initialized by the same seed, which makes them   \ndeterministic\n. The seed type of each RNG type can be different, you can refer to the corresponding   manual pages for details. If no \nseed\n provided, then it will use \nRNG.gen_seed\n to get a \"truly\"   random one.\n\n\nrand(::AbstractRNG{T}[, ::Type{TP}=Float64])\n   returns a random number in the type \nTP\n. \nTP\n is usually an \nUnsigned\n type, and the return value is   expected to be uniformly distributed in {0, 1} at every bit. When \nTP\n is \nFloat64\n (as default), this   function returns a \nFloat64\n value that is expected to be uniformly distributed in $[0, 1)$. The discussion   about this is in the \nConversion to Float\n section.\n\n\n\n\nThe other generic functions such as \nrand(::AbstractRNG, ::Dims)\n and \nrand!(::AbstractRNG, ::AbstractArray)\n defined in \nBase.Random\n still work.\n\n\nThe constructors of all the types of RNG are designed to take the same kind of parameters as \nsrand\n. For example:\n\n\njulia\n \nusing\n \nRNG\n.\nXorshifts\n\n\n\njulia\n \nr1\n \n=\n \nXorshift128Star\n(\n123\n)\n  \n# Create a RNG of Xorshift128Star with the seed \n123\n\n\nRNG.Xorshifts.Xorshift128Star(0x000000003a300074,0x000000003a30004e)\n\n\n\njulia\n \nr2\n \n=\n \nXorshift128Star\n();\n  \n# Use a random value to be the seed.\n\n\n\njulia\n \nrand\n(\nr1\n)\n  \n# Generate a number uniformly distributed in ``[0, 1)``.\n\n\n0.2552720033868119\n\n\n\njulia\n \nA\n \n=\n \nrand\n(\nr1\n,\n \nUInt64\n,\n \n2\n,\n \n3\n)\n  \n# Generate a 2x3 matrix `A` in `UInt64` type.\n\n\n2\u00d73 Array{UInt64,2}:\n\n\n 0xbed3dea863c65407  0x607f5f9815f515af  0x807289d8f9847407\n\n\n 0x4ab80d43269335ee  0xf78b56ada11ea641  0xc2306a55acfb4aaa\n\n\n\njulia\n \nrand!\n(\nr1\n,\n \nA\n)\n  \n# Refill `A` with random numbers.\n\n\n2\u00d73 Array{UInt64,2}:\n\n\n 0xf729352e2a72b541  0xe89948b5582a85f0  0x8a95ebd6aa34fcf4\n\n\n 0xc0c5a8df4c1b160f  0x8b5269ed6c790e08  0x930b89985ae0c865\n\n\n\n\n\n\nPeople will get the same results in their own computers of the above lines. For more interfaces and usage examples, please refer to the manual pages of each RNG.\n\n\n\n\nEmpirical Statistical Testing\n\n\nEmpirical statistical testing is very important for random number generation, because the theoretical mathematical analysis is insufficient to verify the performance of a random number generator.\n\n\nThe famous and highly evaluated \nTestU01\n library\n is chosen to test the RNGs in \nRNG.jl\n. \nTestU01\n offers a collection of test suites, and \nBig Crush\n is the largest and most stringent test battery for empirical testing (which usually takes several hours to run). \nBig Crush\n has revealed a number of flaws of lots of well-used generators, even including the \nMersenne Twister\n (or to be more exact, the \ndSFMT\n) which is currently used in \nBase.Random\n as \nGLOBAL_RAND\n.\n1\n\n\nThis package chooses \nRNGTest.jl\n to use TestU01.\n\n\nThe testing results are available on \nBenchmark\n page.\n\n\n\n\nConversion to Float\n\n\nBesides the statistical flaws, popular generators often neglect the importance of converting unsigned integers to floating numbers. The most common situation is to convert an \nUInt\n to a \nFloat64\n which is uniformly distributed in $[0.0, 1.0)$. For example, neither the \nstd::uniform_real_distribution\n in libstdc++ from gcc, libc++ from llvm, nor the standard library from MSVC has a correct performance, as they all have a non-zero probability for generating the max value which is an open bound and should not be produced.\n\n\nThe cause is that a \nFloat64\n number in $[0.0, 1.0)$ has only 53 \nsignificand\n bits (52 explicitly stored), which means at least 11 bits of an \nUInt64\n are abandoned when being converted to \nFloat64\n. If using the naive approach to multiply an \nUInt64\n by $2^{-64}$, users may get 1.0, and the distribution is not good (although using $2^{-32}$ for an \nUInt32\n is OK).\n\n\nIn this package, we make use of the fact that the distribution of the least 52 bits can be the same in an \nUInt64\n and a \nFloat64\n (if you are familiar with \nIEEE 754\n this is easy to understand). An \nUInt64\n will firstly be converted to a \nFloat64\n that is perfectly uniformly distributed in [1.0, 2.0), and then be minus by one. This is a very fast approach, but not completely ideal, since the one bit is wasted. The current default RNG in \nBase.Random\n library does the same thing, so it also causes some tricky problems.\n2\n\n\n\n\n\n\n\n\n\n\nrand\n fails bigcrush #6464\n\n\n\n\n\n\nLeast significant bit of rand() is always zero #16344", 
            "title": "Bases"
        }, 
        {
            "location": "/man/bases/#bases", 
            "text": "This page describes basic concepts and fundanmental knowledge of  RNG.jl .   Note  Unless otherwise specified, all the random number generators in this package are  pseudorandom  number generators (or  deterministic  random bit generator), which means they only provide numbers whose properties approximate the properties of  truly random  numbers. Always, especially in secure-sensitive cases, keep in mind that they do not gaurantee a totally random performance.", 
            "title": "Bases"
        }, 
        {
            "location": "/man/bases/#installation", 
            "text": "This package is currently not registered, so you have to directly clone it for installation:  julia   Pkg . clone ( https://github.com/sunoru/RNG.jl.git )   And build the dependencies:  julia   Pkg . build ( RNG )   It is recommended to run the test suites before using the package:  julia   Pkg . test ( RNG )", 
            "title": "Installation"
        }, 
        {
            "location": "/man/bases/#interface", 
            "text": "First of all, to use a RNG from this package, you can import  RNG.jl  and use RNG by declare its submodule's name, or directly import the submodule. Then you can create a random number generator of certain type. For example:  julia   using   RNG  julia   r   =   Xorshifts . Xorshift1024Plus ()   or  julia   using   RNG . Xorshifts  julia   r   =   Xorshift1024Plus ()   The submodules have some API in common and a few differently.  All the Random Number Generators (RNGs) are child types of  AbstractRNG{T} , which is a child type of  Base.Random.AbstractRNG  and replaces it. ( Base.Random  may be refactored sometime, anyway.) The type parameter  T  indicates the original output type of a RNG, and it is usually a child type of  Unsigned , such as  UInt64 ,  UInt32 , etc. Users can change the output type of a certain RNG type by use a wrapped type:  WrappedRNG .  Consistent to what  Base.Random  does, there are generic functions:   srand(::AbstractRNG{T}[, seed])    initializes a RNG by one or a sequence of numbers (called  seed ). The output sequences by two RNGs of   the same type should be the same if they are initialized by the same seed, which makes them    deterministic . The seed type of each RNG type can be different, you can refer to the corresponding   manual pages for details. If no  seed  provided, then it will use  RNG.gen_seed  to get a \"truly\"   random one.  rand(::AbstractRNG{T}[, ::Type{TP}=Float64])    returns a random number in the type  TP .  TP  is usually an  Unsigned  type, and the return value is   expected to be uniformly distributed in {0, 1} at every bit. When  TP  is  Float64  (as default), this   function returns a  Float64  value that is expected to be uniformly distributed in $[0, 1)$. The discussion   about this is in the  Conversion to Float  section.   The other generic functions such as  rand(::AbstractRNG, ::Dims)  and  rand!(::AbstractRNG, ::AbstractArray)  defined in  Base.Random  still work.  The constructors of all the types of RNG are designed to take the same kind of parameters as  srand . For example:  julia   using   RNG . Xorshifts  julia   r1   =   Xorshift128Star ( 123 )    # Create a RNG of Xorshift128Star with the seed  123  RNG.Xorshifts.Xorshift128Star(0x000000003a300074,0x000000003a30004e)  julia   r2   =   Xorshift128Star ();    # Use a random value to be the seed.  julia   rand ( r1 )    # Generate a number uniformly distributed in ``[0, 1)``.  0.2552720033868119  julia   A   =   rand ( r1 ,   UInt64 ,   2 ,   3 )    # Generate a 2x3 matrix `A` in `UInt64` type.  2\u00d73 Array{UInt64,2}:   0xbed3dea863c65407  0x607f5f9815f515af  0x807289d8f9847407   0x4ab80d43269335ee  0xf78b56ada11ea641  0xc2306a55acfb4aaa  julia   rand! ( r1 ,   A )    # Refill `A` with random numbers.  2\u00d73 Array{UInt64,2}:   0xf729352e2a72b541  0xe89948b5582a85f0  0x8a95ebd6aa34fcf4   0xc0c5a8df4c1b160f  0x8b5269ed6c790e08  0x930b89985ae0c865   People will get the same results in their own computers of the above lines. For more interfaces and usage examples, please refer to the manual pages of each RNG.", 
            "title": "Interface"
        }, 
        {
            "location": "/man/bases/#empirical-statistical-testing", 
            "text": "Empirical statistical testing is very important for random number generation, because the theoretical mathematical analysis is insufficient to verify the performance of a random number generator.  The famous and highly evaluated  TestU01  library  is chosen to test the RNGs in  RNG.jl .  TestU01  offers a collection of test suites, and  Big Crush  is the largest and most stringent test battery for empirical testing (which usually takes several hours to run).  Big Crush  has revealed a number of flaws of lots of well-used generators, even including the  Mersenne Twister  (or to be more exact, the  dSFMT ) which is currently used in  Base.Random  as  GLOBAL_RAND . 1  This package chooses  RNGTest.jl  to use TestU01.  The testing results are available on  Benchmark  page.", 
            "title": "Empirical Statistical Testing"
        }, 
        {
            "location": "/man/bases/#conversion-to-float", 
            "text": "Besides the statistical flaws, popular generators often neglect the importance of converting unsigned integers to floating numbers. The most common situation is to convert an  UInt  to a  Float64  which is uniformly distributed in $[0.0, 1.0)$. For example, neither the  std::uniform_real_distribution  in libstdc++ from gcc, libc++ from llvm, nor the standard library from MSVC has a correct performance, as they all have a non-zero probability for generating the max value which is an open bound and should not be produced.  The cause is that a  Float64  number in $[0.0, 1.0)$ has only 53  significand  bits (52 explicitly stored), which means at least 11 bits of an  UInt64  are abandoned when being converted to  Float64 . If using the naive approach to multiply an  UInt64  by $2^{-64}$, users may get 1.0, and the distribution is not good (although using $2^{-32}$ for an  UInt32  is OK).  In this package, we make use of the fact that the distribution of the least 52 bits can be the same in an  UInt64  and a  Float64  (if you are familiar with  IEEE 754  this is easy to understand). An  UInt64  will firstly be converted to a  Float64  that is perfectly uniformly distributed in [1.0, 2.0), and then be minus by one. This is a very fast approach, but not completely ideal, since the one bit is wasted. The current default RNG in  Base.Random  library does the same thing, so it also causes some tricky problems. 2      rand  fails bigcrush #6464    Least significant bit of rand() is always zero #16344", 
            "title": "Conversion to Float"
        }, 
        {
            "location": "/man/benchmark/", 
            "text": "Benchmark\n\n\nThis page includes the results of speed tests and big crush tests of several kinds of RNGs in this package. The data is produced on such a computer:\n\n\njulia\n \nversioninfo\n()\n\n\nJulia\n \nVersion\n \n0.5\n.\n0\n-\nrc0\n+\n0\n\n\nCommit\n \n633443\nc\n \n(\n2016\n-\n08\n-\n02\n \n00\n:\n53\n \nUTC\n)\n\n\nPlatform\n \nInfo\n:\n\n  \nSystem\n:\n \nLinux\n \n(\nx86_64\n-\nredhat\n-\nlinux\n)\n\n  \nCPU\n:\n \nIntel\n(\nR\n)\n \nCore\n(\nTM\n)\n \ni5\n-\n3470\n \nCPU\n \n@\n \n3.20\nGHz\n\n  \nWORD_SIZE\n:\n \n64\n\n  \nBLAS\n:\n \nlibopenblas\n \n(\nUSE64BITINT\n \nDYNAMIC_ARCH\n \nNO_AFFINITY\n \nSandybridge\n)\n\n  \nLAPACK\n:\n \nlibopenblas64_\n\n  \nLIBM\n:\n \nlibopenlibm\n\n  \nLLVM\n:\n \nlibLLVM\n-\n3.7\n.\n1\n \n(\nORCJIT\n,\n \nivybridge\n)\n\n\n\n\n\n\nAll the benchmark scripts are in the \nbenchmark\n directory, you can do the tests by yourself.\n\n\n\n\nNote\n\n\nAll the data here is only for reference, and will be updated as this package is updated.\n\n\n\n\n\n\nSpeed Test\n\n\nThe speed test results are as following (the smaller is the better):\n\n\n\n\nand detailed in the table (sorted by speed):\n\n\n\n\n\n\n\n\nRNG Type\n\n\nSpeed (ns/64 bits)\n\n\nRNG Type\n\n\nSpeed (ns/64 bits)\n\n\nRNG Type\n\n\nSpeed (ns/64 bits)\n\n\n\n\n\n\n\n\n\n\nXoroshiro128Star\n\n\n1.184\n\n\nPCG_XSL_RR_128\n\n\n2.646\n\n\nPhilox4x64\n\n\n5.737\n\n\n\n\n\n\nXorshift128Plus\n\n\n1.189\n\n\nPCG_XSH_RS_64\n\n\n2.738\n\n\nThreefry4x64\n\n\n5.965\n\n\n\n\n\n\nXoroshiro128Plus\n\n\n1.393\n\n\nPCG_XSH_RR_128\n\n\n3.260\n\n\nThreefry2x64\n\n\n7.760\n\n\n\n\n\n\nXorshift128Star\n\n\n1.486\n\n\nPCG_XSL_RR_64\n\n\n3.308\n\n\nPhilox2x32\n\n\n9.698\n\n\n\n\n\n\nPCG_RXS_M_XS_64\n\n\n1.522\n\n\nPCG_XSH_RS_128\n\n\n3.373\n\n\nPhilox4x32\n\n\n11.517\n\n\n\n\n\n\nPCG_XSL_RR_RR_128\n\n\n1.602\n\n\nPCG_RXS_M_XS_32\n\n\n3.420\n\n\nThreefry4x32\n\n\n12.241\n\n\n\n\n\n\nXorshift64\n\n\n1.918\n\n\nPCG_XSH_RR_64\n\n\n3.580\n\n\nThreefry2x32\n\n\n16.253\n\n\n\n\n\n\nBaseMT19937*\n\n\n1.971\n\n\nXorshift1024Plus\n\n\n3.725\n\n\nARS1x128\n\n\n17.081\n\n\n\n\n\n\nXorshift64Star\n\n\n2.000\n\n\nXorshift1024Star\n\n\n3.748\n\n\nARS4x32\n\n\n18.059\n\n\n\n\n\n\nPCG_XSL_RR_RR_64\n\n\n2.044\n\n\nMT19937\n\n\n4.229\n\n\nAESNI1x128\n\n\n18.304\n\n\n\n\n\n\nPCG_RXS_M_XS_128\n\n\n2.482\n\n\nPhilox2x64\n\n\n5.161\n\n\nAESNI4x32\n\n\n29.770\n\n\n\n\n\n\n\n\n*\nBaseMT19937\n denotes to \nBase.Random.MersenneTwister\n.\n\n\n\n\nBig Crush Test\n\n\n10 kinds of RNGs (which are worth considering) have been tested with Big Crush test batteries:\n\n\n\n\n\n\n\n\nRNG Type\n\n\nSpeed (ns/64 bits)\n\n\nTotal CPU time\n\n\nFailed Test(s)*\n\n\n\n\n\n\n\n\n\n\nAESNI1x128\n\n\n18.304\n\n\n04:14:22.19\n\n\n\n\n\n\n\n\nARS1x128\n\n\n17.081\n\n\n04:13:27.54\n\n\n55 SampleCorr, k = 1 p-value = 7.0e-4\n\n\n\n\n\n\nBaseMT19937\n\n\n1.971\n\n\n03:18:23.47\n\n\n\n\n\n\n\n\nMT19937\n\n\n4.229\n\n\n03:32:59.06\n\n\n36 Gap, r = 0 p-value = eps\n80LinearComp, r = 0 p-value = 1-eps1\n81  LinearComp, r = 29 p-value = 1-eps1\n\n\n\n\n\n\nPCG_RXS_M_XS_64_64\n\n\n1.522\n\n\n03:20:07.97\n\n\n\n\n\n\n\n\nPCG_XSH_RS_128_64`\n\n\n3.373\n\n\n03:24:57.54\n\n\n54  SampleMean, r = 10              0.9991\n\n\n\n\n\n\nPhilox2x64\n\n\n5.737\n\n\n03:28:52.27\n\n\n35  Gap, r = 25  3.4e-4\n\n\n\n\n\n\nThreefry2x64\n\n\n5.965\n\n\n03:37:53.53\n\n\n\n\n\n\n\n\nXoroshiro128Plus\n\n\n1.393\n\n\n03:33:16.51\n\n\n\n\n\n\n\n\nXorshift1024Star\n\n\n3.748\n\n\n03:39:15.19\n\n\n\n\n\n\n\n\n\n\n*eps means a value \n 1.0e-300, and eps1 means a value \n 1.0e-15.\n\n\nIt is interesting that BaseMT19937 passes all the tests when generating \nUInt64\n (by generating two \nUInt32\n with dSFMT). The PCG ones do not pass all the tests as the paper says, but the failures are just near the threshold. The RNG with best performance here is \nXoroshiro128Plus\n, which passes all the tests and has an excellent speed.", 
            "title": "Benchmark"
        }, 
        {
            "location": "/man/benchmark/#benchmark", 
            "text": "This page includes the results of speed tests and big crush tests of several kinds of RNGs in this package. The data is produced on such a computer:  julia   versioninfo ()  Julia   Version   0.5 . 0 - rc0 + 0  Commit   633443 c   ( 2016 - 08 - 02   00 : 53   UTC )  Platform   Info : \n   System :   Linux   ( x86_64 - redhat - linux ) \n   CPU :   Intel ( R )   Core ( TM )   i5 - 3470   CPU   @   3.20 GHz \n   WORD_SIZE :   64 \n   BLAS :   libopenblas   ( USE64BITINT   DYNAMIC_ARCH   NO_AFFINITY   Sandybridge ) \n   LAPACK :   libopenblas64_ \n   LIBM :   libopenlibm \n   LLVM :   libLLVM - 3.7 . 1   ( ORCJIT ,   ivybridge )   All the benchmark scripts are in the  benchmark  directory, you can do the tests by yourself.   Note  All the data here is only for reference, and will be updated as this package is updated.", 
            "title": "Benchmark"
        }, 
        {
            "location": "/man/benchmark/#speed-test", 
            "text": "The speed test results are as following (the smaller is the better):   and detailed in the table (sorted by speed):     RNG Type  Speed (ns/64 bits)  RNG Type  Speed (ns/64 bits)  RNG Type  Speed (ns/64 bits)      Xoroshiro128Star  1.184  PCG_XSL_RR_128  2.646  Philox4x64  5.737    Xorshift128Plus  1.189  PCG_XSH_RS_64  2.738  Threefry4x64  5.965    Xoroshiro128Plus  1.393  PCG_XSH_RR_128  3.260  Threefry2x64  7.760    Xorshift128Star  1.486  PCG_XSL_RR_64  3.308  Philox2x32  9.698    PCG_RXS_M_XS_64  1.522  PCG_XSH_RS_128  3.373  Philox4x32  11.517    PCG_XSL_RR_RR_128  1.602  PCG_RXS_M_XS_32  3.420  Threefry4x32  12.241    Xorshift64  1.918  PCG_XSH_RR_64  3.580  Threefry2x32  16.253    BaseMT19937*  1.971  Xorshift1024Plus  3.725  ARS1x128  17.081    Xorshift64Star  2.000  Xorshift1024Star  3.748  ARS4x32  18.059    PCG_XSL_RR_RR_64  2.044  MT19937  4.229  AESNI1x128  18.304    PCG_RXS_M_XS_128  2.482  Philox2x64  5.161  AESNI4x32  29.770     * BaseMT19937  denotes to  Base.Random.MersenneTwister .", 
            "title": "Speed Test"
        }, 
        {
            "location": "/man/benchmark/#big-crush-test", 
            "text": "10 kinds of RNGs (which are worth considering) have been tested with Big Crush test batteries:     RNG Type  Speed (ns/64 bits)  Total CPU time  Failed Test(s)*      AESNI1x128  18.304  04:14:22.19     ARS1x128  17.081  04:13:27.54  55 SampleCorr, k = 1 p-value = 7.0e-4    BaseMT19937  1.971  03:18:23.47     MT19937  4.229  03:32:59.06  36 Gap, r = 0 p-value = eps 80LinearComp, r = 0 p-value = 1-eps1 81  LinearComp, r = 29 p-value = 1-eps1    PCG_RXS_M_XS_64_64  1.522  03:20:07.97     PCG_XSH_RS_128_64`  3.373  03:24:57.54  54  SampleMean, r = 10              0.9991    Philox2x64  5.737  03:28:52.27  35  Gap, r = 25  3.4e-4    Threefry2x64  5.965  03:37:53.53     Xoroshiro128Plus  1.393  03:33:16.51     Xorshift1024Star  3.748  03:39:15.19      *eps means a value   1.0e-300, and eps1 means a value   1.0e-15.  It is interesting that BaseMT19937 passes all the tests when generating  UInt64  (by generating two  UInt32  with dSFMT). The PCG ones do not pass all the tests as the paper says, but the failures are just near the threshold. The RNG with best performance here is  Xoroshiro128Plus , which passes all the tests and has an excellent speed.", 
            "title": "Big Crush Test"
        }, 
        {
            "location": "/man/pcg/", 
            "text": "PCG Family\n\n\nPermuted Congruential Generators\n (PCGs) are a family of RNGs which uses a \nlinear congruential generator\n as the state-transition function, and uses \npermutation functions on tuples\n to produce output that is much more random than the RNG's internal state.\n1\n\n\n\n\nPCG Type\n\n\nEach PCG generator is available in four variants, based on how it applies the additive constant for its underlying LCG; the variations are:\n\n\n\n\nPCGStateOneseq\n (single stream):   all instances use the same fixed constant, thus the RNG always somewhere in same sequence.\n\n\nPCGStateMCG\n (mcg):   adds zero, resulting in a single stream and reduced period.\n\n\nPCGStateSetseq\n (specific stream):   the constant can be changed at any time, selecting a different random sequence.\n\n\nPCGStateUnique\n (unique stream):   the constant is based on the memory address of the object, thus every RNG has its own unique sequence.\n\n\n\n\n\n\nPCG Method Type\n\n\n\n\nPCG_XSH_RS\n: high xorshift, followed by a random shift.   It's fast and is a good performer.\n\n\nPCG_XSH_RR\n: high xorshift, followed by a random rotate.   It's fast and is a good performer. Slightly better statistically than \nPCG_XSH_RS\n.\n\n\nPCG_RXS_M_XS\n: fixed xorshift (to low bits), random rotate.   The most statistically powerful generator, but all those steps make it slower than some of the others.   (but in this package the benchmark shows it's even fast than \nPCG_XSH_RS\n, which is an current issue.)\n\n\nPCG_XSL_RR\n: fixed xorshift (to low bits), random rotate.   Useful for 128-bit types that are split across two CPU registers.\n\n\nPCG_XSL_RR_RR\n: fixed xorshift (to low bits), random rotate (both parts).   Useful for 128-bit types that are split across two CPU registers. Use this in need of an invertable   128-bit RNG.\n\n\n\n\n\n\nInterface and Examples\n\n\nAn instance of PCG generator can be created by specify the state type, the output type, the method and seed. When seed is missing it is set to truly random numbers. The default output type is \nUInt64\n, and the default method is \nPCG_XSH_RS\n. The seed will be converted to the internal state type (a kind of unsigned integer), and for PCGs with specific stream (\nPCGStateSetseq\n) the seed should be a \nTuple\n of two \nInteger\ns. Note that not all parameter combinations are available (see \nPCG_LIST\n). For example:\n\n\njulia\n \nusing\n \nRNG\n.\nPCG\n\n\n\njulia\n \nPCGStateOneseq\n(\nUInt64\n,\n \n1234567\n)\n  \n# create a single stream PCG, specifying the output type and seed.\n\n\nRNG.PCG.PCGStateOneseq{UInt128,Val{:XSH_RS},UInt64}(0xa10d40ffc2b1e573e589b22b2450d1fd)\n\n\n\njulia\n \nPCGStateUnique\n(\nPCG_RXS_M_XS\n,\n \n1234567\n);\n  \n# unique stream PCG, specifying the method and seed.\n\n\n\njulia\n \nPCGStateSetseq\n(\nUInt32\n,\n \nPCG_XSH_RR\n,\n \n(\n1234567\n,\n \n7654321\n))\n\n\nRNG.PCG.PCGStateSetseq{UInt64,Val{:XSH_RR},UInt32}(0xfc77de2cd901ff85,0x0000000000e99763)\n\n\n\n\n\n\nbounded_rand\n is provided by this module, in which the bound is must an integer in the output type:\n\n\njulia\n \nr\n \n=\n \nPCGStateOneseq\n(\n1234567\n)\n\n\nRNG.PCG.PCGStateOneseq{UInt128,Val{:XSH_RS},UInt64}(0xa10d40ffc2b1e573e589b22b2450d1fd)\n\n\n\njulia\n \n[\nbounded_rand\n(\nr\n,\n \nUInt64\n(\n100\n))\n \nfor\n \ni\n \nin\n \n1\n:\n6\n]\n\n\n6-element Array{UInt64,1}:\n\n\n 0x0000000000000012\n\n\n 0x000000000000000a\n\n\n 0x000000000000002e\n\n\n 0x0000000000000049\n\n\n 0x0000000000000043\n\n\n 0x000000000000002b\n\n\n\n\n\n\nPCG also has an \nadvance!\n function, used to advance the state of a PCG instance.\n\n\njulia\n \nsrand\n(\nr\n,\n \n1234567\n);\n\n\n\njulia\n \nrand\n(\nr\n,\n \n4\n)\n\n\n4-element Array{Float64,1}:\n\n\n 0.571626 \n\n\n 0.994506 \n\n\n 0.888622 \n\n\n 0.0876384\n\n\n\njulia\n \nadvance!\n(\nr\n,\n \n-\n4\n);\n\n\n\njulia\n \nrand\n(\nr\n,\n \n4\n)\n\n\n4-element Array{Float64,1}:\n\n\n 0.571626 \n\n\n 0.994506 \n\n\n 0.888622 \n\n\n 0.0876384\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nO\u2019NEILL M E. PCG: A Family of Simple Fast Space-Efficient Statistically Good Algorithms for Random Number Generation[J].", 
            "title": "PCG Family"
        }, 
        {
            "location": "/man/pcg/#pcg-family", 
            "text": "Permuted Congruential Generators  (PCGs) are a family of RNGs which uses a  linear congruential generator  as the state-transition function, and uses  permutation functions on tuples  to produce output that is much more random than the RNG's internal state. 1", 
            "title": "PCG Family"
        }, 
        {
            "location": "/man/pcg/#pcg-type", 
            "text": "Each PCG generator is available in four variants, based on how it applies the additive constant for its underlying LCG; the variations are:   PCGStateOneseq  (single stream):   all instances use the same fixed constant, thus the RNG always somewhere in same sequence.  PCGStateMCG  (mcg):   adds zero, resulting in a single stream and reduced period.  PCGStateSetseq  (specific stream):   the constant can be changed at any time, selecting a different random sequence.  PCGStateUnique  (unique stream):   the constant is based on the memory address of the object, thus every RNG has its own unique sequence.", 
            "title": "PCG Type"
        }, 
        {
            "location": "/man/pcg/#pcg-method-type", 
            "text": "PCG_XSH_RS : high xorshift, followed by a random shift.   It's fast and is a good performer.  PCG_XSH_RR : high xorshift, followed by a random rotate.   It's fast and is a good performer. Slightly better statistically than  PCG_XSH_RS .  PCG_RXS_M_XS : fixed xorshift (to low bits), random rotate.   The most statistically powerful generator, but all those steps make it slower than some of the others.   (but in this package the benchmark shows it's even fast than  PCG_XSH_RS , which is an current issue.)  PCG_XSL_RR : fixed xorshift (to low bits), random rotate.   Useful for 128-bit types that are split across two CPU registers.  PCG_XSL_RR_RR : fixed xorshift (to low bits), random rotate (both parts).   Useful for 128-bit types that are split across two CPU registers. Use this in need of an invertable   128-bit RNG.", 
            "title": "PCG Method Type"
        }, 
        {
            "location": "/man/pcg/#interface-and-examples", 
            "text": "An instance of PCG generator can be created by specify the state type, the output type, the method and seed. When seed is missing it is set to truly random numbers. The default output type is  UInt64 , and the default method is  PCG_XSH_RS . The seed will be converted to the internal state type (a kind of unsigned integer), and for PCGs with specific stream ( PCGStateSetseq ) the seed should be a  Tuple  of two  Integer s. Note that not all parameter combinations are available (see  PCG_LIST ). For example:  julia   using   RNG . PCG  julia   PCGStateOneseq ( UInt64 ,   1234567 )    # create a single stream PCG, specifying the output type and seed.  RNG.PCG.PCGStateOneseq{UInt128,Val{:XSH_RS},UInt64}(0xa10d40ffc2b1e573e589b22b2450d1fd)  julia   PCGStateUnique ( PCG_RXS_M_XS ,   1234567 );    # unique stream PCG, specifying the method and seed.  julia   PCGStateSetseq ( UInt32 ,   PCG_XSH_RR ,   ( 1234567 ,   7654321 ))  RNG.PCG.PCGStateSetseq{UInt64,Val{:XSH_RR},UInt32}(0xfc77de2cd901ff85,0x0000000000e99763)   bounded_rand  is provided by this module, in which the bound is must an integer in the output type:  julia   r   =   PCGStateOneseq ( 1234567 )  RNG.PCG.PCGStateOneseq{UInt128,Val{:XSH_RS},UInt64}(0xa10d40ffc2b1e573e589b22b2450d1fd)  julia   [ bounded_rand ( r ,   UInt64 ( 100 ))   for   i   in   1 : 6 ]  6-element Array{UInt64,1}:   0x0000000000000012   0x000000000000000a   0x000000000000002e   0x0000000000000049   0x0000000000000043   0x000000000000002b   PCG also has an  advance!  function, used to advance the state of a PCG instance.  julia   srand ( r ,   1234567 );  julia   rand ( r ,   4 )  4-element Array{Float64,1}:   0.571626    0.994506    0.888622    0.0876384  julia   advance! ( r ,   - 4 );  julia   rand ( r ,   4 )  4-element Array{Float64,1}:   0.571626    0.994506    0.888622    0.0876384       O\u2019NEILL M E. PCG: A Family of Simple Fast Space-Efficient Statistically Good Algorithms for Random Number Generation[J].", 
            "title": "Interface and Examples"
        }, 
        {
            "location": "/man/mersenne-twisters/", 
            "text": "Mersenne Twisters\n\n\nThe \nMersenne Twister\n1\n is so far the most widely used PRNG. Mersenne Twisters are taken as default random number generators of a great many of software systems, including the Julia language until the current 0.5 version. The most commonly used version of Mersenne Twisters is \nMT19937\n, which has a very long period of $2^{19937}-1$ and passes numerous tests including the Diehard tests.\n\n\nHowever, it also has many flaws by today's standards. For the large period, MT19937 has to use a 2.5 KiB state buffer, which place a load on the memory caches. More severely, it cannot pass all the TestU01 statistical tests\n2\n, and the speed is not so fast. \nSo it is not recommended in most situations.\n\n\nThe \nMersenneTwisters\n in this package currently only provides one RNG: \nMT19937\n. \nMT19937\n can only produce \nUInt32\n numbers as output. Its state is an array of 624 \nUInt32\n numbers, so it takes 624 \nUInt32\ns as seed. A default function is also provided to deal with one \nUInt32\n as seed.\n\n\n\n\nExamples\n\n\nTo use the Mersenne Twisters, firstly import the module:\n\n\njulia\n \nusing\n \nRNG\n.\nMersenneTwisters\n\n\n\n\n\n\nA certain sequence can be used to initialize an instance of MT19937:\n\n\njulia\n \nseed\n \n=\n \n((\nUInt32\n(\ni\n)\n \nfor\n \ni\n \nin\n \n1\n:\n624\n)\n...\n);\n  \n# This is a Tuple of 1..624\n\n\n\njulia\n \nr\n \n=\n \nMT19937\n(\nseed\n);\n\n\n\n\n\n\nSince MT19937 is a RNG based on linear-feedback shift-register techniques, this approach is not recommended for an obivous reason:\n\n\njulia\n \nrand\n(\nr\n,\n \nUInt32\n,\n \n10\n)\n\n\n10-element Array{UInt32,1}:\n\n\n 0x0000018f\n\n\n 0x983ba049\n\n\n 0x00000192\n\n\n 0x983ba054\n\n\n 0x00000191\n\n\n 0x983ba057\n\n\n 0x00000190\n\n\n 0x983ba056\n\n\n 0x00000193\n\n\n 0x983ba055\n\n\n\n\n\n\nThe firstly generated numbers are so poorly random. This is because the most bits of states are zeros. So it is better to create a \nMT19937\n in this way:\n\n\njulia\n \nr\n \n=\n \nMT19937\n();\n\n\n\n\n\n\nIn this case, all the 624 states will be filled with truly random numbers produced by \nRandomDevice\n. If someone needs the reproducibility, just save the state \nr.mt\n and use it for next time.\n\n\nAn initialization function described in the original paper\n1\n is also implemented here, so the seed can also be just one \nUInt32\n number (or an \nInteger\n whose least 32 bits will be truncated):\n\n\njulia\n \nsrand\n(\nr\n,\n \n0xabcdef12\n);\n\n\n\njulia\n \nrand\n(\nr\n,\n \nUInt32\n,\n \n10\n)\n\n\n10-element Array{UInt32,1}:\n\n\n 0x63ec7b30\n\n\n 0x71b2167e\n\n\n 0x6c339700\n\n\n 0x1cfaa505\n\n\n 0xc7a81f4d\n\n\n 0x3319b105\n\n\n 0x457db8ba\n\n\n 0xc9d4ccd8\n\n\n 0x811f30a0\n\n\n 0x627ecfbe\n\n\n\n\n\n\nNote that if you use one \nUInt32\n number as seed, you will always get in a bias way.\n3\n\n\n\n\n\n\n\n\n\n\nMatsumoto M, Nishimura T. Mersenne twister: a 623-dimensionally equidistributed uniform pseudo-random number generator[J]. ACM Transactions on Modeling and Computer Simulation (TOMACS), 1998, 8(1): 3-30. doi:\n10.1145/272991.272995\n.\n\n\n\n\n\n\nL'Ecuyer P, Simard R. TestU01: AC library for empirical testing of random number generators[J]. ACM Transactions on Mathematical Software (TOMS), 2007, 33(4): 22. doi:\n10.1145/1268776.1268777\n\n\n\n\n\n\nC++ Seeding Surprises", 
            "title": "Mersenne Twisters"
        }, 
        {
            "location": "/man/mersenne-twisters/#mersenne-twisters", 
            "text": "The  Mersenne Twister 1  is so far the most widely used PRNG. Mersenne Twisters are taken as default random number generators of a great many of software systems, including the Julia language until the current 0.5 version. The most commonly used version of Mersenne Twisters is  MT19937 , which has a very long period of $2^{19937}-1$ and passes numerous tests including the Diehard tests.  However, it also has many flaws by today's standards. For the large period, MT19937 has to use a 2.5 KiB state buffer, which place a load on the memory caches. More severely, it cannot pass all the TestU01 statistical tests 2 , and the speed is not so fast.  So it is not recommended in most situations.  The  MersenneTwisters  in this package currently only provides one RNG:  MT19937 .  MT19937  can only produce  UInt32  numbers as output. Its state is an array of 624  UInt32  numbers, so it takes 624  UInt32 s as seed. A default function is also provided to deal with one  UInt32  as seed.", 
            "title": "Mersenne Twisters"
        }, 
        {
            "location": "/man/mersenne-twisters/#examples", 
            "text": "To use the Mersenne Twisters, firstly import the module:  julia   using   RNG . MersenneTwisters   A certain sequence can be used to initialize an instance of MT19937:  julia   seed   =   (( UInt32 ( i )   for   i   in   1 : 624 ) ... );    # This is a Tuple of 1..624  julia   r   =   MT19937 ( seed );   Since MT19937 is a RNG based on linear-feedback shift-register techniques, this approach is not recommended for an obivous reason:  julia   rand ( r ,   UInt32 ,   10 )  10-element Array{UInt32,1}:   0x0000018f   0x983ba049   0x00000192   0x983ba054   0x00000191   0x983ba057   0x00000190   0x983ba056   0x00000193   0x983ba055   The firstly generated numbers are so poorly random. This is because the most bits of states are zeros. So it is better to create a  MT19937  in this way:  julia   r   =   MT19937 ();   In this case, all the 624 states will be filled with truly random numbers produced by  RandomDevice . If someone needs the reproducibility, just save the state  r.mt  and use it for next time.  An initialization function described in the original paper 1  is also implemented here, so the seed can also be just one  UInt32  number (or an  Integer  whose least 32 bits will be truncated):  julia   srand ( r ,   0xabcdef12 );  julia   rand ( r ,   UInt32 ,   10 )  10-element Array{UInt32,1}:   0x63ec7b30   0x71b2167e   0x6c339700   0x1cfaa505   0xc7a81f4d   0x3319b105   0x457db8ba   0xc9d4ccd8   0x811f30a0   0x627ecfbe   Note that if you use one  UInt32  number as seed, you will always get in a bias way. 3      Matsumoto M, Nishimura T. Mersenne twister: a 623-dimensionally equidistributed uniform pseudo-random number generator[J]. ACM Transactions on Modeling and Computer Simulation (TOMACS), 1998, 8(1): 3-30. doi: 10.1145/272991.272995 .    L'Ecuyer P, Simard R. TestU01: AC library for empirical testing of random number generators[J]. ACM Transactions on Mathematical Software (TOMS), 2007, 33(4): 22. doi: 10.1145/1268776.1268777    C++ Seeding Surprises", 
            "title": "Examples"
        }, 
        {
            "location": "/man/random123/", 
            "text": "Random123 Family\n\n\nRandom123\n is a library of \"counter-based\" random number generators (CBRNGs), developed by D.E.Shaw Research\n1\n. \nCounter-based\n means the RNGs in this family can produce the $\\mathrm{N}^{th}$ number by applying a stateless mixing function to the \ncounter\n $\\mathrm{N}$, instead of the conventional approach of using $\\mathrm{N}$ iterations of a stateful transformation. There are four kinds of RNGs in Random123: \nThreefry\n, \nPhilox\n, \nAESNI\n, \nARS\n.\n\n\nThe original paper\n1\n says all the RNGs in Random123 can pass Big Crush in TestU01, but in the \nbenchmark\n we did, \nARS1x128\n and \nPhilox2x64\n have a slight failure.\n\n\n\n\nRandom123 RNGs\n\n\nAll the RNG types in Random123 have a property \nctr1\n, which denotes to its first \ncounter\n, and some of them have \nctr2\n for the second \ncounter\n. The suffix '-1x', '-2x' and '-4x' indicates how many numbers will be generated per time. The first one or two or four properties of a RNG type in Random123 are always \nx\n(or \nx1\n, \nx2\n, etc.), which denote to the produced numbers.\n\n\n\n\nThreefry\n\n\nThreefry\n is a \nnon-cryptographic\n adaptation of the Threefish block cipher from the \nSkein Hash Function\n.\n\n\nIn this package, there are two \nType\ns of \nThreefry\n: \nThreefry4x\n and \nThreefry2x\n. Besides the output type \nT\n, there is another parameter \nR\n, which denotes to the number of rounds, and must be at least 1 and no more than 32. With 20 rounds (by default), \nThreefry\n has a considerable safety margin over the minimum number of rounds with no known statistical flaws, but still has excellent performance. They both support \nUInt32\n and \nUInt64\n output.\n\n\n\n\nPhilox\n\n\nPhilox\n uses a Feistel network and integer multiplication.\n\n\nPhilox\n also has two \nType\ns: \nPhilox4x\n and \nPhilox2x\n. The number of rounds must be at least 1 and no more than 16. With 10 rounds (by default), Philox2x32 has a considerable safety margin over the minimum number of rounds with no known statistical flaws, but still has excellent performance. They both support \nUInt32\n and \nUInt64\n output.\n\n\n\n\nAESNI\n\n\nAESNI\n uses the Advanced Encryption Standard (AES) New Instruction, available on certain modern x86 processors (some models of Intel Westmere and Sandy Bridge, and AMD Interlagos, as of 2011). AESNI CBRNGs can operate on \nUInt128\n type.\n\n\nAESNI\n has two \nType\ns: \nAESNI1x\n and \nAESNI4x\n. \nAESNI4x\n only internally converts \nUInt128\n to \nUInt32\n.\n\n\n\n\nARS\n\n\nARS\n (Advanced Randomization System) is a \nnon-cryptographic\n simplification of \nAESNI\n.\n\n\nARS\n has two \nType\ns: \nARS1x\n and \nARS4x\n. \nARS4x\n only internally converts \nUInt128\n to \nUInt32\n. Note that although it uses some cryptographic primitives, \nARS1x\n uses a cryptographically weak key schedule and is \nnot\n suitable for cryptographic use. The number of rounds must be at least 1 and no more than 10, and is 7 by default.\n\n\n\n\nExamples\n\n\nFor detailed usage of each RNG, please refer to the \nlibrary docs\n.\n\n\nTo use Random123, firstly import the module:\n\n\njulia\n \nusing\n \nRNG\n.\nRandom123\n\n\n\n\n\n\nTake \nPhilox4x64\n for example:\n\n\njulia\n \nr\n \n=\n \nPhilox4x\n();\n  \n# will output UInt64 by default, and two seed integers are truly randomly produced.\n\n\n\njulia\n \nr\n \n=\n \nPhilox4x\n((\n0x12345678abcdef01\n,\n \n0x10fedcba87654321\n));\n  \n# specify the seed.\n\n\n\njulia\n \nr\n \n=\n \nPhilox4x\n(\nUInt64\n,\n \n(\n0x12345678abcdef01\n,\n \n0x10fedcba87654321\n));\n  \n# specify both the output type and seed.\n\n\n\njulia\n \nrand\n(\nr\n,\n \nNTuple\n{\n4\n,\n \nUInt64\n})\n\n\n(0x00d626ee85b7d2ed,0xa57b4af2b68c655e,0x82dad737de789de2,0x8d390e05845e6c4d)\n\n\n\njulia\n \nset_counter!\n(\nr\n,\n \n123\n);\n  \n# update the counter manually.\n\n\n\njulia\n \nrand\n(\nr\n,\n \nUInt64\n,\n \n4\n)\n\n\n4-element Array{UInt64,1}:\n\n\n 0x56a4eb812faa9cd7\n\n\n 0xf3d3464a49b23b56\n\n\n 0xda5a5824aea0b2bb\n\n\n 0x097a8d117a2bb20a\n\n\n\njulia\n \nset_counter!\n(\nr\n,\n \n0\n);\n\n\n\njulia\n \nrand\n(\nr\n,\n \nNTuple\n{\n4\n,\n \nUInt64\n})\n\n\n(0x00d626ee85b7d2ed,0xa57b4af2b68c655e,0x82dad737de789de2,0x8d390e05845e6c4d)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nJohn K. Salmon, Mark A. Moraes, Ron O. Dror, and David E. Shaw, \"Parallel Random Numbers: As Easy as 1, 2, 3,\" Proceedings of the International Conference for High Performance Computing, Networking, Storage and Analysis (SC11), New York, NY: ACM, 2011. doi:\n10.1145/2063384.2063405", 
            "title": "Random123 Family"
        }, 
        {
            "location": "/man/random123/#random123-family", 
            "text": "Random123  is a library of \"counter-based\" random number generators (CBRNGs), developed by D.E.Shaw Research 1 .  Counter-based  means the RNGs in this family can produce the $\\mathrm{N}^{th}$ number by applying a stateless mixing function to the  counter  $\\mathrm{N}$, instead of the conventional approach of using $\\mathrm{N}$ iterations of a stateful transformation. There are four kinds of RNGs in Random123:  Threefry ,  Philox ,  AESNI ,  ARS .  The original paper 1  says all the RNGs in Random123 can pass Big Crush in TestU01, but in the  benchmark  we did,  ARS1x128  and  Philox2x64  have a slight failure.", 
            "title": "Random123 Family"
        }, 
        {
            "location": "/man/random123/#random123-rngs", 
            "text": "All the RNG types in Random123 have a property  ctr1 , which denotes to its first  counter , and some of them have  ctr2  for the second  counter . The suffix '-1x', '-2x' and '-4x' indicates how many numbers will be generated per time. The first one or two or four properties of a RNG type in Random123 are always  x (or  x1 ,  x2 , etc.), which denote to the produced numbers.", 
            "title": "Random123 RNGs"
        }, 
        {
            "location": "/man/random123/#threefry", 
            "text": "Threefry  is a  non-cryptographic  adaptation of the Threefish block cipher from the  Skein Hash Function .  In this package, there are two  Type s of  Threefry :  Threefry4x  and  Threefry2x . Besides the output type  T , there is another parameter  R , which denotes to the number of rounds, and must be at least 1 and no more than 32. With 20 rounds (by default),  Threefry  has a considerable safety margin over the minimum number of rounds with no known statistical flaws, but still has excellent performance. They both support  UInt32  and  UInt64  output.", 
            "title": "Threefry"
        }, 
        {
            "location": "/man/random123/#philox", 
            "text": "Philox  uses a Feistel network and integer multiplication.  Philox  also has two  Type s:  Philox4x  and  Philox2x . The number of rounds must be at least 1 and no more than 16. With 10 rounds (by default), Philox2x32 has a considerable safety margin over the minimum number of rounds with no known statistical flaws, but still has excellent performance. They both support  UInt32  and  UInt64  output.", 
            "title": "Philox"
        }, 
        {
            "location": "/man/random123/#aesni", 
            "text": "AESNI  uses the Advanced Encryption Standard (AES) New Instruction, available on certain modern x86 processors (some models of Intel Westmere and Sandy Bridge, and AMD Interlagos, as of 2011). AESNI CBRNGs can operate on  UInt128  type.  AESNI  has two  Type s:  AESNI1x  and  AESNI4x .  AESNI4x  only internally converts  UInt128  to  UInt32 .", 
            "title": "AESNI"
        }, 
        {
            "location": "/man/random123/#ars", 
            "text": "ARS  (Advanced Randomization System) is a  non-cryptographic  simplification of  AESNI .  ARS  has two  Type s:  ARS1x  and  ARS4x .  ARS4x  only internally converts  UInt128  to  UInt32 . Note that although it uses some cryptographic primitives,  ARS1x  uses a cryptographically weak key schedule and is  not  suitable for cryptographic use. The number of rounds must be at least 1 and no more than 10, and is 7 by default.", 
            "title": "ARS"
        }, 
        {
            "location": "/man/random123/#examples", 
            "text": "For detailed usage of each RNG, please refer to the  library docs .  To use Random123, firstly import the module:  julia   using   RNG . Random123   Take  Philox4x64  for example:  julia   r   =   Philox4x ();    # will output UInt64 by default, and two seed integers are truly randomly produced.  julia   r   =   Philox4x (( 0x12345678abcdef01 ,   0x10fedcba87654321 ));    # specify the seed.  julia   r   =   Philox4x ( UInt64 ,   ( 0x12345678abcdef01 ,   0x10fedcba87654321 ));    # specify both the output type and seed.  julia   rand ( r ,   NTuple { 4 ,   UInt64 })  (0x00d626ee85b7d2ed,0xa57b4af2b68c655e,0x82dad737de789de2,0x8d390e05845e6c4d)  julia   set_counter! ( r ,   123 );    # update the counter manually.  julia   rand ( r ,   UInt64 ,   4 )  4-element Array{UInt64,1}:   0x56a4eb812faa9cd7   0xf3d3464a49b23b56   0xda5a5824aea0b2bb   0x097a8d117a2bb20a  julia   set_counter! ( r ,   0 );  julia   rand ( r ,   NTuple { 4 ,   UInt64 })  (0x00d626ee85b7d2ed,0xa57b4af2b68c655e,0x82dad737de789de2,0x8d390e05845e6c4d)       John K. Salmon, Mark A. Moraes, Ron O. Dror, and David E. Shaw, \"Parallel Random Numbers: As Easy as 1, 2, 3,\" Proceedings of the International Conference for High Performance Computing, Networking, Storage and Analysis (SC11), New York, NY: ACM, 2011. doi: 10.1145/2063384.2063405", 
            "title": "Examples"
        }, 
        {
            "location": "/man/xorshifts/", 
            "text": "Xorshift Family\n\n\nXorshift\n family is a class of PRNGs based on linear transformation that takes the \nexclusive or\n of a number with a \nbit-shifted\n version of itself\n1\n. They are extremely fast on mordern computer architectures, and are very suitable for non-cryptographically-secure use. The suffix \n-Star\n and \n-Plus\n in the RNG names denote to two classes of improved RNGs\n2\n3\n, which make it to pass Big Crush in TestU01. \n-Star\n RNGs are obtained by scrambling the output of a normal \nXorshift\n generator with a 64-bit invertible multiplier, while \n-Plus\n RNGs return the sum of two consecutive output of a \nXorshift\n generator.\n\n\nIn this package there are four series of RNG types:\n\n\n\n\nXorshift64\n and \nXorshift64Star\n:   They have a period of $2^{64}$, but not recommended because 64 bits of state are not enough for any   serious purpose.\n\n\nXorshift128\n, \nXorshift128Star\n and \nXorshift128Plus\n:   They have a period of $2^{128}$. \nXorshift128Plus\n is presently used in the JavaScript engines of   Chrome, Firefox and Safari.\n\n\nXorshift1024\n, \nXorshift1024Star\n and \nXorshift1024Plus\n:   They have a long period of $2^{1024}$, and takes some more space for storing the state. If you are   running large-scale parallel simulations, it's a good choice to use \nXorshift1024Star\n.\n\n\nXoroshiro128\n, \nXoroshiro128Star\n and \nXoroshiro128Plus\n:   The successor to \nXorshift128\n series. They make use of a carefully handcrafted shift/rotate-based linear   transformation, resulting in a significant improvement in speed and in statistical quality. Therefore,   \nXoroshiro128Plus\n is the current best suggestion for replacing other low-quality generators.\n\n\n\n\nAll the RNG types produce \nUInt64\n numbers, if you have need for other output type, see \nWrappedRNG\n.\n\n\n\n\nExamples\n\n\nThe usage of \nXorshift\n family is very simple and common:\n\n\njulia\n \nusing\n \nRNG\n.\nXorshifts\n\n\n\njulia\n \nr\n \n=\n \nXoroshiro128Plus\n();\n  \n# create a RNG with truly random seed.\n\n\n\njulia\n \nr\n \n=\n \nXoroshiro128Plus\n(\n0x1234567890abcdef\n)\n  \n# with a certain seed.\n\n\nRNG.Xorshifts.Xoroshiro128Plus(0x13c5b80b0f92f3ac,0xcdd3f80fa9fb6887)\n\n\n\njulia\n \nrand\n(\nr\n)\n\n\n0.6054942367825447\n\n\n\njulia\n \nrand\n(\nr\n,\n \nUInt32\n)\n\n\n0xa688929c\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMarsaglia G. Xorshift rngs[J]. Journal of Statistical Software, 2003, 8(14): 1-6. doi:\n10.18637/jss.v008.i14\n\n\n\n\n\n\nVigna S. An experimental exploration of Marsaglia's xorshift generators, scrambled[J]. arXiv preprint \narXiv:1402.6246\n, 2014.\n\n\n\n\n\n\nVigna S. Further scramblings of Marsaglia's xorshift generators[J]. arXiv preprint \narXiv:1404.0390\n, 2014.", 
            "title": "Xorshift Family"
        }, 
        {
            "location": "/man/xorshifts/#xorshift-family", 
            "text": "Xorshift  family is a class of PRNGs based on linear transformation that takes the  exclusive or  of a number with a  bit-shifted  version of itself 1 . They are extremely fast on mordern computer architectures, and are very suitable for non-cryptographically-secure use. The suffix  -Star  and  -Plus  in the RNG names denote to two classes of improved RNGs 2 3 , which make it to pass Big Crush in TestU01.  -Star  RNGs are obtained by scrambling the output of a normal  Xorshift  generator with a 64-bit invertible multiplier, while  -Plus  RNGs return the sum of two consecutive output of a  Xorshift  generator.  In this package there are four series of RNG types:   Xorshift64  and  Xorshift64Star :   They have a period of $2^{64}$, but not recommended because 64 bits of state are not enough for any   serious purpose.  Xorshift128 ,  Xorshift128Star  and  Xorshift128Plus :   They have a period of $2^{128}$.  Xorshift128Plus  is presently used in the JavaScript engines of   Chrome, Firefox and Safari.  Xorshift1024 ,  Xorshift1024Star  and  Xorshift1024Plus :   They have a long period of $2^{1024}$, and takes some more space for storing the state. If you are   running large-scale parallel simulations, it's a good choice to use  Xorshift1024Star .  Xoroshiro128 ,  Xoroshiro128Star  and  Xoroshiro128Plus :   The successor to  Xorshift128  series. They make use of a carefully handcrafted shift/rotate-based linear   transformation, resulting in a significant improvement in speed and in statistical quality. Therefore,    Xoroshiro128Plus  is the current best suggestion for replacing other low-quality generators.   All the RNG types produce  UInt64  numbers, if you have need for other output type, see  WrappedRNG .", 
            "title": "Xorshift Family"
        }, 
        {
            "location": "/man/xorshifts/#examples", 
            "text": "The usage of  Xorshift  family is very simple and common:  julia   using   RNG . Xorshifts  julia   r   =   Xoroshiro128Plus ();    # create a RNG with truly random seed.  julia   r   =   Xoroshiro128Plus ( 0x1234567890abcdef )    # with a certain seed.  RNG.Xorshifts.Xoroshiro128Plus(0x13c5b80b0f92f3ac,0xcdd3f80fa9fb6887)  julia   rand ( r )  0.6054942367825447  julia   rand ( r ,   UInt32 )  0xa688929c       Marsaglia G. Xorshift rngs[J]. Journal of Statistical Software, 2003, 8(14): 1-6. doi: 10.18637/jss.v008.i14    Vigna S. An experimental exploration of Marsaglia's xorshift generators, scrambled[J]. arXiv preprint  arXiv:1402.6246 , 2014.    Vigna S. Further scramblings of Marsaglia's xorshift generators[J]. arXiv preprint  arXiv:1404.0390 , 2014.", 
            "title": "Examples"
        }, 
        {
            "location": "/lib/rng/", 
            "text": "RNG\n\n\n\n\nIndex\n\n\n\n\nRNG\n\n\nRNG.AbstractRNG\n\n\nRNG.WrappedRNG\n\n\nRNG.gen_seed\n\n\nRNG.output_type\n\n\n\n\n\n\nPublic\n\n\n#\n\n\nRNG\n \n \nModule\n.\n\n\nMain module for \nRNG.jl\n \u2013 a random number generator package for Julia Language.\n\n\nThis module exports two types and four submodules:\n\n\n\n\nAbstractRNG\n.\n\n\nWrappedRNG\n.\n\n\nPCG\n.\n\n\nMersenneTwisters\n.\n\n\nRandom123\n.\n\n\nXorshifts\n.\n\n\n\n\nsource\n\n\n#\n\n\nRNG.AbstractRNG\n \n \nType\n.\n\n\nAbstractRNG\n{\nT\n}\n \n:\n \nBase\n.\nRandom\n.\nAbstractRNG\n\n\n\n\n\n\nThe abstract type of Random Number Generators. T indicates the original output type of a RNG.\n\n\nsource\n\n\n#\n\n\nRNG.WrappedRNG\n \n \nType\n.\n\n\nWrappedRNG\n{\nR\n,\n \nT1\n,\n \nT2\n}\n \n:\n \nAbstractRNG\n{\nT2\n}\n\n\nWrappedRNG\n(\nbase_rng\n,\n \nT2\n)\n\n\nWrappedRNG\n(\nR\n,\n \nT2\n,\n \nargs\n...\n)\n\n\n\n\n\n\nWrap a RNG which originally provides output in T1 into a RNG that provides output in T2.\n\n\nExamples\n\n\njulia\n \nr\n \n=\n \nXorshifts\n.\nXorshift128Star\n(\n123\n);\n\n\n\njulia\n \nRNG\n.\noutput_type\n(\nr\n)\n\n\nUInt64\n\n\n\njulia\n \nr1\n \n=\n \nWrappedRNG\n(\nr\n,\n \nUInt32\n);\n\n\n\njulia\n \nRNG\n.\noutput_type\n(\nr1\n)\n\n\nUInt32\n\n\n\njulia\n \nr2\n \n=\n \nWrappedRNG\n(\nXorshifts\n.\nXorshift128Star\n,\n \nUInt32\n,\n \n123\n);\n\n\n\njulia\n \nRNG\n.\noutput_type\n(\nr2\n)\n\n\nUInt32\n\n\n\njulia\n \n@\nTest\n.\ntest\n \nrand\n(\nr1\n,\n \nUInt32\n,\n \n3\n)\n \n==\n \nrand\n(\nr2\n,\n \nUInt32\n,\n \n3\n)\n\n\nTest Passed\n\n\n  Expression: rand(r1,UInt32,3) == rand(r2,UInt32,3)\n\n\n   Evaluated: UInt32[0x18a21796,0x20241598,0x63c65407] == UInt32[0x18a21796,0x20241598,0x63c65407]\n\n\n\n\n\n\nsource\n\n\n\n\nInternal\n\n\n#\n\n\nRNG.gen_seed\n \n \nMethod\n.\n\n\ngen_seed\n(\nT\n[,\n \nn\n])\n\n\n\n\n\n\nGenerate a tuple of \nn\n truly random numbers in type \nT\n. If \nn\n is missing, return only one number. The \"truly\" random numbers are provided by the random device of system. See \nBase.Random.RandomDevice\n.\n\n\nExamples\n\n\njulia\n \nRNG\n.\ngen_seed\n(\nUInt64\n,\n \n2\n)\n  \n# The output should probably be different on different computers.\n\n\n(\n0x26aa3fe5e306f725\n,\n0x7b9dc3c227d8acc9\n)\n\n\n\njulia\n \nRNG\n.\ngen_seed\n(\nUInt32\n)\n\n\n0x9ba60fdc\n\n\n\n\n\n\nsource\n\n\n#\n\n\nRNG.output_type\n \n \nMethod\n.\n\n\nGet the original output type of a RNG.\n\n\nsource", 
            "title": "RNG"
        }, 
        {
            "location": "/lib/rng/#rng", 
            "text": "", 
            "title": "RNG"
        }, 
        {
            "location": "/lib/rng/#index", 
            "text": "RNG  RNG.AbstractRNG  RNG.WrappedRNG  RNG.gen_seed  RNG.output_type", 
            "title": "Index"
        }, 
        {
            "location": "/lib/rng/#public", 
            "text": "#  RNG     Module .  Main module for  RNG.jl  \u2013 a random number generator package for Julia Language.  This module exports two types and four submodules:   AbstractRNG .  WrappedRNG .  PCG .  MersenneTwisters .  Random123 .  Xorshifts .   source  #  RNG.AbstractRNG     Type .  AbstractRNG { T }   :   Base . Random . AbstractRNG   The abstract type of Random Number Generators. T indicates the original output type of a RNG.  source  #  RNG.WrappedRNG     Type .  WrappedRNG { R ,   T1 ,   T2 }   :   AbstractRNG { T2 }  WrappedRNG ( base_rng ,   T2 )  WrappedRNG ( R ,   T2 ,   args ... )   Wrap a RNG which originally provides output in T1 into a RNG that provides output in T2.  Examples  julia   r   =   Xorshifts . Xorshift128Star ( 123 );  julia   RNG . output_type ( r )  UInt64  julia   r1   =   WrappedRNG ( r ,   UInt32 );  julia   RNG . output_type ( r1 )  UInt32  julia   r2   =   WrappedRNG ( Xorshifts . Xorshift128Star ,   UInt32 ,   123 );  julia   RNG . output_type ( r2 )  UInt32  julia   @ Test . test   rand ( r1 ,   UInt32 ,   3 )   ==   rand ( r2 ,   UInt32 ,   3 )  Test Passed    Expression: rand(r1,UInt32,3) == rand(r2,UInt32,3)     Evaluated: UInt32[0x18a21796,0x20241598,0x63c65407] == UInt32[0x18a21796,0x20241598,0x63c65407]   source", 
            "title": "Public"
        }, 
        {
            "location": "/lib/rng/#internal", 
            "text": "#  RNG.gen_seed     Method .  gen_seed ( T [,   n ])   Generate a tuple of  n  truly random numbers in type  T . If  n  is missing, return only one number. The \"truly\" random numbers are provided by the random device of system. See  Base.Random.RandomDevice .  Examples  julia   RNG . gen_seed ( UInt64 ,   2 )    # The output should probably be different on different computers.  ( 0x26aa3fe5e306f725 , 0x7b9dc3c227d8acc9 )  julia   RNG . gen_seed ( UInt32 )  0x9ba60fdc   source  #  RNG.output_type     Method .  Get the original output type of a RNG.  source", 
            "title": "Internal"
        }, 
        {
            "location": "/lib/pcg/", 
            "text": "PCG\n\n\n\n\nIndex\n\n\n\n\nRNG.PCG\n\n\nRNG.PCG.PCGMethod\n\n\nRNG.PCG.PCG_LIST\n\n\nRNG.PCG.AbstractPCG\n\n\nRNG.PCG.PCGStateMCG\n\n\nRNG.PCG.PCGStateOneseq\n\n\nRNG.PCG.PCGStateSetseq\n\n\nRNG.PCG.PCGStateUnique\n\n\nRNG.PCG.PCG_RXS_M_XS\n\n\nRNG.PCG.PCG_XSH_RR\n\n\nRNG.PCG.PCG_XSH_RS\n\n\nRNG.PCG.PCG_XSL_RR\n\n\nRNG.PCG.PCG_XSL_RR_RR\n\n\nRNG.PCG.advance!\n\n\nRNG.PCG.bounded_rand\n\n\nRNG.PCG.default_increment\n\n\nRNG.PCG.default_multiplier\n\n\nRNG.PCG.mcg_multiplier\n\n\nRNG.PCG.mcg_unmultiplier\n\n\nRNG.PCG.pcg_advance!\n\n\nRNG.PCG.pcg_advance_lcg\n\n\nRNG.PCG.pcg_output\n\n\nRNG.PCG.pcg_srand\n\n\nRNG.PCG.pcg_step!\n\n\n\n\n\n\nPublic\n\n\n#\n\n\nRNG.PCG\n \n \nModule\n.\n\n\nThe module for \nPCG Family\n.\n\n\nsource\n\n\n#\n\n\nRNG.PCG.PCGMethod\n \n \nConstant\n.\n\n\nThe \nUnion\n of all the PCG method types: \nPCG_XSH_RS\n, \nPCG_XSH_RR\n, \nPCG_RXS_M_XS\n, \nPCG_XSL_RR\n, and \nPCG_XSL_RR_RR\n.\n\n\nsource\n\n\n#\n\n\nRNG.PCG.PCG_LIST\n \n \nConstant\n.\n\n\nThe list of all the parameter combinations that can be used for PCG.\n\n\n\n\n\n\n\n\nStream variation\n\n\nState Type\n\n\nMethod Type\n\n\nOutput Type\n\n\n\n\n\n\n\n\n\n\nPCGStateOneseq\n\n\nUInt16\n\n\nPCG_XSH_RS\n\n\nUInt8\n\n\n\n\n\n\nPCGStateOneseq\n\n\nUInt32\n\n\nPCG_XSH_RS\n\n\nUInt16\n\n\n\n\n\n\nPCGStateOneseq\n\n\nUInt64\n\n\nPCG_XSH_RS\n\n\nUInt32\n\n\n\n\n\n\nPCGStateOneseq\n\n\nUInt128\n\n\nPCG_XSH_RS\n\n\nUInt64\n\n\n\n\n\n\nPCGStateUnique\n\n\nUInt16\n\n\nPCG_XSH_RS\n\n\nUInt8\n\n\n\n\n\n\nPCGStateUnique\n\n\nUInt32\n\n\nPCG_XSH_RS\n\n\nUInt16\n\n\n\n\n\n\nPCGStateUnique\n\n\nUInt64\n\n\nPCG_XSH_RS\n\n\nUInt32\n\n\n\n\n\n\nPCGStateUnique\n\n\nUInt128\n\n\nPCG_XSH_RS\n\n\nUInt64\n\n\n\n\n\n\nPCGStateSetseq\n\n\nUInt16\n\n\nPCG_XSH_RS\n\n\nUInt8\n\n\n\n\n\n\nPCGStateSetseq\n\n\nUInt32\n\n\nPCG_XSH_RS\n\n\nUInt16\n\n\n\n\n\n\nPCGStateSetseq\n\n\nUInt64\n\n\nPCG_XSH_RS\n\n\nUInt32\n\n\n\n\n\n\nPCGStateSetseq\n\n\nUInt128\n\n\nPCG_XSH_RS\n\n\nUInt64\n\n\n\n\n\n\nPCGStateMCG\n\n\nUInt16\n\n\nPCG_XSH_RS\n\n\nUInt8\n\n\n\n\n\n\nPCGStateMCG\n\n\nUInt32\n\n\nPCG_XSH_RS\n\n\nUInt16\n\n\n\n\n\n\nPCGStateMCG\n\n\nUInt64\n\n\nPCG_XSH_RS\n\n\nUInt32\n\n\n\n\n\n\nPCGStateMCG\n\n\nUInt128\n\n\nPCG_XSH_RS\n\n\nUInt64\n\n\n\n\n\n\nPCGStateOneseq\n\n\nUInt16\n\n\nPCG_XSH_RR\n\n\nUInt8\n\n\n\n\n\n\nPCGStateOneseq\n\n\nUInt32\n\n\nPCG_XSH_RR\n\n\nUInt16\n\n\n\n\n\n\nPCGStateOneseq\n\n\nUInt64\n\n\nPCG_XSH_RR\n\n\nUInt32\n\n\n\n\n\n\nPCGStateOneseq\n\n\nUInt128\n\n\nPCG_XSH_RR\n\n\nUInt64\n\n\n\n\n\n\nPCGStateUnique\n\n\nUInt16\n\n\nPCG_XSH_RR\n\n\nUInt8\n\n\n\n\n\n\nPCGStateUnique\n\n\nUInt32\n\n\nPCG_XSH_RR\n\n\nUInt16\n\n\n\n\n\n\nPCGStateUnique\n\n\nUInt64\n\n\nPCG_XSH_RR\n\n\nUInt32\n\n\n\n\n\n\nPCGStateUnique\n\n\nUInt128\n\n\nPCG_XSH_RR\n\n\nUInt64\n\n\n\n\n\n\nPCGStateSetseq\n\n\nUInt16\n\n\nPCG_XSH_RR\n\n\nUInt8\n\n\n\n\n\n\nPCGStateSetseq\n\n\nUInt32\n\n\nPCG_XSH_RR\n\n\nUInt16\n\n\n\n\n\n\nPCGStateSetseq\n\n\nUInt64\n\n\nPCG_XSH_RR\n\n\nUInt32\n\n\n\n\n\n\nPCGStateSetseq\n\n\nUInt128\n\n\nPCG_XSH_RR\n\n\nUInt64\n\n\n\n\n\n\nPCGStateMCG\n\n\nUInt16\n\n\nPCG_XSH_RR\n\n\nUInt8\n\n\n\n\n\n\nPCGStateMCG\n\n\nUInt32\n\n\nPCG_XSH_RR\n\n\nUInt16\n\n\n\n\n\n\nPCGStateMCG\n\n\nUInt64\n\n\nPCG_XSH_RR\n\n\nUInt32\n\n\n\n\n\n\nPCGStateMCG\n\n\nUInt128\n\n\nPCG_XSH_RR\n\n\nUInt64\n\n\n\n\n\n\nPCGStateOneseq\n\n\nUInt8\n\n\nPCG_RXS_M_XS\n\n\nUInt8\n\n\n\n\n\n\nPCGStateOneseq\n\n\nUInt16\n\n\nPCG_RXS_M_XS\n\n\nUInt16\n\n\n\n\n\n\nPCGStateOneseq\n\n\nUInt32\n\n\nPCG_RXS_M_XS\n\n\nUInt32\n\n\n\n\n\n\nPCGStateOneseq\n\n\nUInt64\n\n\nPCG_RXS_M_XS\n\n\nUInt64\n\n\n\n\n\n\nPCGStateOneseq\n\n\nUInt128\n\n\nPCG_RXS_M_XS\n\n\nUInt128\n\n\n\n\n\n\nPCGStateUnique\n\n\nUInt16\n\n\nPCG_RXS_M_XS\n\n\nUInt16\n\n\n\n\n\n\nPCGStateUnique\n\n\nUInt32\n\n\nPCG_RXS_M_XS\n\n\nUInt32\n\n\n\n\n\n\nPCGStateUnique\n\n\nUInt64\n\n\nPCG_RXS_M_XS\n\n\nUInt64\n\n\n\n\n\n\nPCGStateUnique\n\n\nUInt128\n\n\nPCG_RXS_M_XS\n\n\nUInt128\n\n\n\n\n\n\nPCGStateSetseq\n\n\nUInt8\n\n\nPCG_RXS_M_XS\n\n\nUInt8\n\n\n\n\n\n\nPCGStateSetseq\n\n\nUInt16\n\n\nPCG_RXS_M_XS\n\n\nUInt16\n\n\n\n\n\n\nPCGStateSetseq\n\n\nUInt32\n\n\nPCG_RXS_M_XS\n\n\nUInt32\n\n\n\n\n\n\nPCGStateSetseq\n\n\nUInt64\n\n\nPCG_RXS_M_XS\n\n\nUInt64\n\n\n\n\n\n\nPCGStateSetseq\n\n\nUInt128\n\n\nPCG_RXS_M_XS\n\n\nUInt128\n\n\n\n\n\n\nPCGStateOneseq\n\n\nUInt64\n\n\nPCG_XSL_RR\n\n\nUInt32\n\n\n\n\n\n\nPCGStateOneseq\n\n\nUInt128\n\n\nPCG_XSL_RR\n\n\nUInt64\n\n\n\n\n\n\nPCGStateUnique\n\n\nUInt64\n\n\nPCG_XSL_RR\n\n\nUInt32\n\n\n\n\n\n\nPCGStateUnique\n\n\nUInt128\n\n\nPCG_XSL_RR\n\n\nUInt64\n\n\n\n\n\n\nPCGStateSetseq\n\n\nUInt64\n\n\nPCG_XSL_RR\n\n\nUInt32\n\n\n\n\n\n\nPCGStateSetseq\n\n\nUInt128\n\n\nPCG_XSL_RR\n\n\nUInt64\n\n\n\n\n\n\nPCGStateMCG\n\n\nUInt64\n\n\nPCG_XSL_RR\n\n\nUInt32\n\n\n\n\n\n\nPCGStateMCG\n\n\nUInt128\n\n\nPCG_XSL_RR\n\n\nUInt64\n\n\n\n\n\n\nPCGStateOneseq\n\n\nUInt64\n\n\nPCG_XSL_RR_RR\n\n\nUInt64\n\n\n\n\n\n\nPCGStateOneseq\n\n\nUInt128\n\n\nPCG_XSL_RR_RR\n\n\nUInt128\n\n\n\n\n\n\nPCGStateUnique\n\n\nUInt64\n\n\nPCG_XSL_RR_RR\n\n\nUInt64\n\n\n\n\n\n\nPCGStateUnique\n\n\nUInt128\n\n\nPCG_XSL_RR_RR\n\n\nUInt128\n\n\n\n\n\n\nPCGStateSetseq\n\n\nUInt64\n\n\nPCG_XSL_RR_RR\n\n\nUInt64\n\n\n\n\n\n\nPCGStateSetseq\n\n\nUInt128\n\n\nPCG_XSL_RR_RR\n\n\nUInt128\n\n\n\n\n\n\n\n\nsource\n\n\n#\n\n\nRNG.PCG.PCGStateMCG\n \n \nType\n.\n\n\nPCGStateMCG\n{\nStateType\n:\nPCGUInt\n,\n \nMethodType\n:\nPCGMethod\n,\n \nOutputType\n:\nPCGUInt\n}\n \n:\n\n    \nAbstractPCG\n{\nStateType\n,\n \nMethodType\n,\n \nOutputType\n}\n\n\nPCGStateMCG\n([\nseed\n])\n\n\nPCGStateMCG\n(\noutput_type\n[,\n \nseed\n])\n\n\nPCGStateMCG\n(\nmethod\n[,\n \nseed\n])\n\n\nPCGStateMCG\n(\noutput_type\n[,\n \nmethod\n,\n \nseed\n])\n\n\n\n\n\n\nPCG generator with \nMCG\n, where the increment is zero, resulting in a single stream and reduced period.\n\n\nseed\n is an \nInteger\n which will be automatically converted to the state type.\n\n\noutput_type\n is the type of the PCG's output. If missing it is set to \nUInt64\n.\n\n\nmethod\n is one of the \nPCGMethod\n. If missing it is set to \nPCG_XSH_RS\n.\n\n\nSee \nPCG_LIST\n for the available parameter combinations.\n\n\nsource\n\n\n#\n\n\nRNG.PCG.PCGStateOneseq\n \n \nType\n.\n\n\nPCGStateOneseq\n{\nStateType\n:\nPCGUInt\n,\n \nMethodType\n:\nPCGMethod\n,\n \nOutputType\n:\nPCGUInt\n}\n \n:\n\n    \nAbstractPCG\n{\nStateType\n,\n \nMethodType\n,\n \nOutputType\n}\n\n\nPCGStateOneseq\n([\nseed\n])\n\n\nPCGStateOneseq\n(\noutput_type\n[,\n \nseed\n])\n\n\nPCGStateOneseq\n(\nmethod\n[,\n \nseed\n])\n\n\nPCGStateOneseq\n(\noutput_type\n[,\n \nmethod\n,\n \nseed\n])\n\n\n\n\n\n\nPCG generator with \nsingle streams\n, where all instances use the same fixed constant, thus the RNG always somewhere in same sequence.\n\n\nseed\n is an \nInteger\n which will be automatically converted to the state type.\n\n\noutput_type\n is the type of the PCG's output. If missing it is set to \nUInt64\n.\n\n\nmethod\n is one of the \nPCGMethod\n. If missing it is set to \nPCG_XSH_RS\n.\n\n\nSee \nPCG_LIST\n for the available parameter combinations.\n\n\nsource\n\n\n#\n\n\nRNG.PCG.PCGStateSetseq\n \n \nType\n.\n\n\nPCGStateSetseq\n{\nStateType\n:\nPCGUInt\n,\n \nMethodType\n:\nPCGMethod\n,\n \nOutputType\n:\nPCGUInt\n}\n \n:\n\n    \nAbstractPCG\n{\nStateType\n,\n \nMethodType\n,\n \nOutputType\n}\n\n\nPCGStateSetseq\n([\nseed\n])\n\n\nPCGStateSetseq\n(\noutput_type\n[,\n \nseed\n])\n\n\nPCGStateSetseq\n(\nmethod\n[,\n \nseed\n])\n\n\nPCGStateSetseq\n(\noutput_type\n[,\n \nmethod\n,\n \nseed\n])\n\n\n\n\n\n\nPCG generator with \nspecific streams\n, where the constant can be changed at any time, selecting a different random sequence.\n\n\nseed\n is a \nTuple\n of two \nInteger\ns which will both be automatically converted to the state type.\n\n\noutput_type\n is the type of the PCG's output. If missing it is set to \nUInt64\n.\n\n\nmethod\n is one of the \nPCGMethod\n. If missing it is set to \nPCG_XSH_RS\n.\n\n\nSee \nPCG_LIST\n for the available parameter combinations.\n\n\nsource\n\n\n#\n\n\nRNG.PCG.PCGStateUnique\n \n \nType\n.\n\n\nPCGStateUnique\n{\nStateType\n:\nPCGUInt\n,\n \nMethodType\n:\nPCGMethod\n,\n \nOutputType\n:\nPCGUInt\n}\n \n:\n\n    \nAbstractPCG\n{\nStateType\n,\n \nMethodType\n,\n \nOutputType\n}\n\n\nPCGStateUnique\n([\nseed\n])\n\n\nPCGStateUnique\n(\noutput_type\n[,\n \nseed\n])\n\n\nPCGStateUnique\n(\nmethod\n[,\n \nseed\n])\n\n\nPCGStateUnique\n(\noutput_type\n[,\n \nmethod\n,\n \nseed\n])\n\n\n\n\n\n\nPCG generator with \nunique streams\n, where the constant is based on the memory address of the object, thus every RNG has its own unique sequence.\n\n\nseed\n is an \nInteger\n which will be automatically converted to the state type.\n\n\noutput_type\n is the type of the PCG's output. If missing it is set to \nUInt64\n.\n\n\nmethod\n is one of the \nPCGMethod\n. If missing it is set to \nPCG_XSH_RS\n.\n\n\nSee \nPCG_LIST\n for the available parameter combinations.\n\n\nsource\n\n\n#\n\n\nRNG.PCG.PCG_RXS_M_XS\n \n \nType\n.\n\n\nOne of PCG output method: random xorshift, mcg multiply, fixed xorshift.\n\n\nThe most statistically powerful generator, but slower than some of the others.\n\n\nsource\n\n\n#\n\n\nRNG.PCG.PCG_XSH_RR\n \n \nType\n.\n\n\nOne of PCG output method: high xorshift, followed by a random rotate.\n\n\nFast. Slightly better statistically than \nPCG_XSH_RS\n.\n\n\nsource\n\n\n#\n\n\nRNG.PCG.PCG_XSH_RS\n \n \nType\n.\n\n\nOne of PCG output method: high xorshift, followed by a random shift.\n\n\nFast.\n\n\nsource\n\n\n#\n\n\nRNG.PCG.PCG_XSL_RR\n \n \nType\n.\n\n\nOne of PCG output method: fixed xorshift (to low bits), random rotate.\n\n\nUseful for 128-bit types that are split across two CPU registers.\n\n\nsource\n\n\n#\n\n\nRNG.PCG.PCG_XSL_RR_RR\n \n \nType\n.\n\n\nOne of PCG output method: fixed xorshift (to low bits), random rotate (both parts).\n\n\nUseful for 128-bit types that are split across two CPU registers. Use this in need of an invertable 128-bit RNG.\n\n\nsource\n\n\n#\n\n\nRNG.PCG.advance!\n \n \nMethod\n.\n\n\nadvance!\n(\nr\n,\n \n\u0394\n)\n\n\n\n\n\n\nAdvance a PCG object \nr\n for \n\u0394\n steps.\n\n\nExamples\n\n\njulia\n \nr\n \n=\n \nPCGStateSetseq\n(\nUInt64\n,\n \nPCG_RXS_M_XS\n,\n \n(\n123\n,\n \n321\n))\n\n\nRNG.PCG.PCGStateSetseq{UInt64,Val{:RXS_M_XS},UInt64}(0x45389f8b27528b29,0x0000000000000283)\n\n\n\njulia\n \nA\n \n=\n \nrand\n(\nr\n,\n \nUInt64\n,\n \n2\n);\n\n\n\njulia\n \np\n \n=\n \nrand\n(\nr\n);\n\n\n\njulia\n \nr\n\n\nRNG.PCG.PCGStateSetseq{UInt64,Val{:RXS_M_XS},UInt64}(0x9b1fc763ae0ad702,0x0000000000000283)\n\n\n\njulia\n \nadvance!\n(\nr\n,\n \n-\n3\n)\n\n\nRNG.PCG.PCGStateSetseq{UInt64,Val{:RXS_M_XS},UInt64}(0x45389f8b27528b29,0x0000000000000283)\n\n\n\njulia\n \n@\nTest\n.\ntest\n \nA\n \n==\n \nrand\n(\nr\n,\n \nUInt64\n,\n \n2\n)\n\n\nTest Passed\n\n\n  Expression: A == rand(r,UInt64,2)\n\n\n   Evaluated: UInt64[0x245806d421c0d835,0x5b6bc4b066eda37f] == UInt64[0x245806d421c0d835,0x5b6bc4b066eda37f]\n\n\n\njulia\n \n@\nTest\n.\ntest\n \np\n \n==\n \nrand\n(\nr\n)\n\n\nTest Passed\n\n\n  Expression: p == rand(r)\n\n\n   Evaluated: 0.3950038072091506 == 0.3950038072091506\n\n\n\n\n\n\nsource\n\n\n#\n\n\nRNG.PCG.bounded_rand\n \n \nMethod\n.\n\n\nbounded_rand\n(\nr\n,\n \nbound\n)\n\n\n\n\n\n\nProducing a random number less than a given \nbound\n in the output type.\n\n\nsource\n\n\n\n\nInternal\n\n\n#\n\n\nRNG.PCG.AbstractPCG\n \n \nType\n.\n\n\nAbstractPCG\n{\nStateType\n:\nPCGUInt\n,\n \nMethodType\n:\nPCGMethod\n,\n \nOutputType\n:\nPCGUInt\n}\n \n:\n \nAbstractRNG\n{\nOutputType\n}\n\n\n\n\n\n\nThe base abstract type for PCGs.\n\n\nsource\n\n\n#\n\n\nRNG.PCG.default_increment\n \n \nMethod\n.\n\n\nReturn the default increment for a certain type.\n\n\nsource\n\n\n#\n\n\nRNG.PCG.default_multiplier\n \n \nMethod\n.\n\n\nReturn the default multiplier for a certain type.\n\n\nsource\n\n\n#\n\n\nRNG.PCG.mcg_multiplier\n \n \nMethod\n.\n\n\nReturn the default MCG multiplier for a certain type.\n\n\nsource\n\n\n#\n\n\nRNG.PCG.mcg_unmultiplier\n \n \nMethod\n.\n\n\nReturn the default MCG unmultiplier for a certain type.\n\n\nsource\n\n\n#\n\n\nRNG.PCG.pcg_advance!\n \n \nFunction\n.\n\n\nAdvance a PCG object.\n\n\nsource\n\n\n#\n\n\nRNG.PCG.pcg_advance_lcg\n \n \nMethod\n.\n\n\nGeneral advance functions.\n\n\nsource\n\n\n#\n\n\nRNG.PCG.pcg_output\n \n \nFunction\n.\n\n\nReturn the output of a state for a certain PCG type.\n\n\nsource\n\n\n#\n\n\nRNG.PCG.pcg_srand\n \n \nFunction\n.\n\n\nInitialize a PCG object.\n\n\nsource\n\n\n#\n\n\nRNG.PCG.pcg_step!\n \n \nFunction\n.\n\n\nDo one iteration step for a PCG object.\n\n\nsource", 
            "title": "PCG"
        }, 
        {
            "location": "/lib/pcg/#pcg", 
            "text": "", 
            "title": "PCG"
        }, 
        {
            "location": "/lib/pcg/#index", 
            "text": "RNG.PCG  RNG.PCG.PCGMethod  RNG.PCG.PCG_LIST  RNG.PCG.AbstractPCG  RNG.PCG.PCGStateMCG  RNG.PCG.PCGStateOneseq  RNG.PCG.PCGStateSetseq  RNG.PCG.PCGStateUnique  RNG.PCG.PCG_RXS_M_XS  RNG.PCG.PCG_XSH_RR  RNG.PCG.PCG_XSH_RS  RNG.PCG.PCG_XSL_RR  RNG.PCG.PCG_XSL_RR_RR  RNG.PCG.advance!  RNG.PCG.bounded_rand  RNG.PCG.default_increment  RNG.PCG.default_multiplier  RNG.PCG.mcg_multiplier  RNG.PCG.mcg_unmultiplier  RNG.PCG.pcg_advance!  RNG.PCG.pcg_advance_lcg  RNG.PCG.pcg_output  RNG.PCG.pcg_srand  RNG.PCG.pcg_step!", 
            "title": "Index"
        }, 
        {
            "location": "/lib/pcg/#public", 
            "text": "#  RNG.PCG     Module .  The module for  PCG Family .  source  #  RNG.PCG.PCGMethod     Constant .  The  Union  of all the PCG method types:  PCG_XSH_RS ,  PCG_XSH_RR ,  PCG_RXS_M_XS ,  PCG_XSL_RR , and  PCG_XSL_RR_RR .  source  #  RNG.PCG.PCG_LIST     Constant .  The list of all the parameter combinations that can be used for PCG.     Stream variation  State Type  Method Type  Output Type      PCGStateOneseq  UInt16  PCG_XSH_RS  UInt8    PCGStateOneseq  UInt32  PCG_XSH_RS  UInt16    PCGStateOneseq  UInt64  PCG_XSH_RS  UInt32    PCGStateOneseq  UInt128  PCG_XSH_RS  UInt64    PCGStateUnique  UInt16  PCG_XSH_RS  UInt8    PCGStateUnique  UInt32  PCG_XSH_RS  UInt16    PCGStateUnique  UInt64  PCG_XSH_RS  UInt32    PCGStateUnique  UInt128  PCG_XSH_RS  UInt64    PCGStateSetseq  UInt16  PCG_XSH_RS  UInt8    PCGStateSetseq  UInt32  PCG_XSH_RS  UInt16    PCGStateSetseq  UInt64  PCG_XSH_RS  UInt32    PCGStateSetseq  UInt128  PCG_XSH_RS  UInt64    PCGStateMCG  UInt16  PCG_XSH_RS  UInt8    PCGStateMCG  UInt32  PCG_XSH_RS  UInt16    PCGStateMCG  UInt64  PCG_XSH_RS  UInt32    PCGStateMCG  UInt128  PCG_XSH_RS  UInt64    PCGStateOneseq  UInt16  PCG_XSH_RR  UInt8    PCGStateOneseq  UInt32  PCG_XSH_RR  UInt16    PCGStateOneseq  UInt64  PCG_XSH_RR  UInt32    PCGStateOneseq  UInt128  PCG_XSH_RR  UInt64    PCGStateUnique  UInt16  PCG_XSH_RR  UInt8    PCGStateUnique  UInt32  PCG_XSH_RR  UInt16    PCGStateUnique  UInt64  PCG_XSH_RR  UInt32    PCGStateUnique  UInt128  PCG_XSH_RR  UInt64    PCGStateSetseq  UInt16  PCG_XSH_RR  UInt8    PCGStateSetseq  UInt32  PCG_XSH_RR  UInt16    PCGStateSetseq  UInt64  PCG_XSH_RR  UInt32    PCGStateSetseq  UInt128  PCG_XSH_RR  UInt64    PCGStateMCG  UInt16  PCG_XSH_RR  UInt8    PCGStateMCG  UInt32  PCG_XSH_RR  UInt16    PCGStateMCG  UInt64  PCG_XSH_RR  UInt32    PCGStateMCG  UInt128  PCG_XSH_RR  UInt64    PCGStateOneseq  UInt8  PCG_RXS_M_XS  UInt8    PCGStateOneseq  UInt16  PCG_RXS_M_XS  UInt16    PCGStateOneseq  UInt32  PCG_RXS_M_XS  UInt32    PCGStateOneseq  UInt64  PCG_RXS_M_XS  UInt64    PCGStateOneseq  UInt128  PCG_RXS_M_XS  UInt128    PCGStateUnique  UInt16  PCG_RXS_M_XS  UInt16    PCGStateUnique  UInt32  PCG_RXS_M_XS  UInt32    PCGStateUnique  UInt64  PCG_RXS_M_XS  UInt64    PCGStateUnique  UInt128  PCG_RXS_M_XS  UInt128    PCGStateSetseq  UInt8  PCG_RXS_M_XS  UInt8    PCGStateSetseq  UInt16  PCG_RXS_M_XS  UInt16    PCGStateSetseq  UInt32  PCG_RXS_M_XS  UInt32    PCGStateSetseq  UInt64  PCG_RXS_M_XS  UInt64    PCGStateSetseq  UInt128  PCG_RXS_M_XS  UInt128    PCGStateOneseq  UInt64  PCG_XSL_RR  UInt32    PCGStateOneseq  UInt128  PCG_XSL_RR  UInt64    PCGStateUnique  UInt64  PCG_XSL_RR  UInt32    PCGStateUnique  UInt128  PCG_XSL_RR  UInt64    PCGStateSetseq  UInt64  PCG_XSL_RR  UInt32    PCGStateSetseq  UInt128  PCG_XSL_RR  UInt64    PCGStateMCG  UInt64  PCG_XSL_RR  UInt32    PCGStateMCG  UInt128  PCG_XSL_RR  UInt64    PCGStateOneseq  UInt64  PCG_XSL_RR_RR  UInt64    PCGStateOneseq  UInt128  PCG_XSL_RR_RR  UInt128    PCGStateUnique  UInt64  PCG_XSL_RR_RR  UInt64    PCGStateUnique  UInt128  PCG_XSL_RR_RR  UInt128    PCGStateSetseq  UInt64  PCG_XSL_RR_RR  UInt64    PCGStateSetseq  UInt128  PCG_XSL_RR_RR  UInt128     source  #  RNG.PCG.PCGStateMCG     Type .  PCGStateMCG { StateType : PCGUInt ,   MethodType : PCGMethod ,   OutputType : PCGUInt }   : \n     AbstractPCG { StateType ,   MethodType ,   OutputType }  PCGStateMCG ([ seed ])  PCGStateMCG ( output_type [,   seed ])  PCGStateMCG ( method [,   seed ])  PCGStateMCG ( output_type [,   method ,   seed ])   PCG generator with  MCG , where the increment is zero, resulting in a single stream and reduced period.  seed  is an  Integer  which will be automatically converted to the state type.  output_type  is the type of the PCG's output. If missing it is set to  UInt64 .  method  is one of the  PCGMethod . If missing it is set to  PCG_XSH_RS .  See  PCG_LIST  for the available parameter combinations.  source  #  RNG.PCG.PCGStateOneseq     Type .  PCGStateOneseq { StateType : PCGUInt ,   MethodType : PCGMethod ,   OutputType : PCGUInt }   : \n     AbstractPCG { StateType ,   MethodType ,   OutputType }  PCGStateOneseq ([ seed ])  PCGStateOneseq ( output_type [,   seed ])  PCGStateOneseq ( method [,   seed ])  PCGStateOneseq ( output_type [,   method ,   seed ])   PCG generator with  single streams , where all instances use the same fixed constant, thus the RNG always somewhere in same sequence.  seed  is an  Integer  which will be automatically converted to the state type.  output_type  is the type of the PCG's output. If missing it is set to  UInt64 .  method  is one of the  PCGMethod . If missing it is set to  PCG_XSH_RS .  See  PCG_LIST  for the available parameter combinations.  source  #  RNG.PCG.PCGStateSetseq     Type .  PCGStateSetseq { StateType : PCGUInt ,   MethodType : PCGMethod ,   OutputType : PCGUInt }   : \n     AbstractPCG { StateType ,   MethodType ,   OutputType }  PCGStateSetseq ([ seed ])  PCGStateSetseq ( output_type [,   seed ])  PCGStateSetseq ( method [,   seed ])  PCGStateSetseq ( output_type [,   method ,   seed ])   PCG generator with  specific streams , where the constant can be changed at any time, selecting a different random sequence.  seed  is a  Tuple  of two  Integer s which will both be automatically converted to the state type.  output_type  is the type of the PCG's output. If missing it is set to  UInt64 .  method  is one of the  PCGMethod . If missing it is set to  PCG_XSH_RS .  See  PCG_LIST  for the available parameter combinations.  source  #  RNG.PCG.PCGStateUnique     Type .  PCGStateUnique { StateType : PCGUInt ,   MethodType : PCGMethod ,   OutputType : PCGUInt }   : \n     AbstractPCG { StateType ,   MethodType ,   OutputType }  PCGStateUnique ([ seed ])  PCGStateUnique ( output_type [,   seed ])  PCGStateUnique ( method [,   seed ])  PCGStateUnique ( output_type [,   method ,   seed ])   PCG generator with  unique streams , where the constant is based on the memory address of the object, thus every RNG has its own unique sequence.  seed  is an  Integer  which will be automatically converted to the state type.  output_type  is the type of the PCG's output. If missing it is set to  UInt64 .  method  is one of the  PCGMethod . If missing it is set to  PCG_XSH_RS .  See  PCG_LIST  for the available parameter combinations.  source  #  RNG.PCG.PCG_RXS_M_XS     Type .  One of PCG output method: random xorshift, mcg multiply, fixed xorshift.  The most statistically powerful generator, but slower than some of the others.  source  #  RNG.PCG.PCG_XSH_RR     Type .  One of PCG output method: high xorshift, followed by a random rotate.  Fast. Slightly better statistically than  PCG_XSH_RS .  source  #  RNG.PCG.PCG_XSH_RS     Type .  One of PCG output method: high xorshift, followed by a random shift.  Fast.  source  #  RNG.PCG.PCG_XSL_RR     Type .  One of PCG output method: fixed xorshift (to low bits), random rotate.  Useful for 128-bit types that are split across two CPU registers.  source  #  RNG.PCG.PCG_XSL_RR_RR     Type .  One of PCG output method: fixed xorshift (to low bits), random rotate (both parts).  Useful for 128-bit types that are split across two CPU registers. Use this in need of an invertable 128-bit RNG.  source  #  RNG.PCG.advance!     Method .  advance! ( r ,   \u0394 )   Advance a PCG object  r  for  \u0394  steps.  Examples  julia   r   =   PCGStateSetseq ( UInt64 ,   PCG_RXS_M_XS ,   ( 123 ,   321 ))  RNG.PCG.PCGStateSetseq{UInt64,Val{:RXS_M_XS},UInt64}(0x45389f8b27528b29,0x0000000000000283)  julia   A   =   rand ( r ,   UInt64 ,   2 );  julia   p   =   rand ( r );  julia   r  RNG.PCG.PCGStateSetseq{UInt64,Val{:RXS_M_XS},UInt64}(0x9b1fc763ae0ad702,0x0000000000000283)  julia   advance! ( r ,   - 3 )  RNG.PCG.PCGStateSetseq{UInt64,Val{:RXS_M_XS},UInt64}(0x45389f8b27528b29,0x0000000000000283)  julia   @ Test . test   A   ==   rand ( r ,   UInt64 ,   2 )  Test Passed    Expression: A == rand(r,UInt64,2)     Evaluated: UInt64[0x245806d421c0d835,0x5b6bc4b066eda37f] == UInt64[0x245806d421c0d835,0x5b6bc4b066eda37f]  julia   @ Test . test   p   ==   rand ( r )  Test Passed    Expression: p == rand(r)     Evaluated: 0.3950038072091506 == 0.3950038072091506   source  #  RNG.PCG.bounded_rand     Method .  bounded_rand ( r ,   bound )   Producing a random number less than a given  bound  in the output type.  source", 
            "title": "Public"
        }, 
        {
            "location": "/lib/pcg/#internal", 
            "text": "#  RNG.PCG.AbstractPCG     Type .  AbstractPCG { StateType : PCGUInt ,   MethodType : PCGMethod ,   OutputType : PCGUInt }   :   AbstractRNG { OutputType }   The base abstract type for PCGs.  source  #  RNG.PCG.default_increment     Method .  Return the default increment for a certain type.  source  #  RNG.PCG.default_multiplier     Method .  Return the default multiplier for a certain type.  source  #  RNG.PCG.mcg_multiplier     Method .  Return the default MCG multiplier for a certain type.  source  #  RNG.PCG.mcg_unmultiplier     Method .  Return the default MCG unmultiplier for a certain type.  source  #  RNG.PCG.pcg_advance!     Function .  Advance a PCG object.  source  #  RNG.PCG.pcg_advance_lcg     Method .  General advance functions.  source  #  RNG.PCG.pcg_output     Function .  Return the output of a state for a certain PCG type.  source  #  RNG.PCG.pcg_srand     Function .  Initialize a PCG object.  source  #  RNG.PCG.pcg_step!     Function .  Do one iteration step for a PCG object.  source", 
            "title": "Internal"
        }, 
        {
            "location": "/lib/mersenne-twisters/", 
            "text": "MersenneTwisters\n\n\n\n\nIndex\n\n\n\n\nRNG.MersenneTwisters\n\n\nRNG.MersenneTwisters.MT19937\n\n\nRNG.MersenneTwisters.MersenneTwister\n\n\nRNG.MersenneTwisters.mt_get\n\n\nRNG.MersenneTwisters.mt_set!\n\n\nRNG.MersenneTwisters.mt_set!\n\n\n\n\n\n\nPublic\n\n\n#\n\n\nRNG.MersenneTwisters\n \n \nModule\n.\n\n\nThe module for \nMersenne Twisters\n.\n\n\nCurrently only provide one RNG type:\n\n\n\n\nMT19937\n\n\n\n\nsource\n\n\n#\n\n\nRNG.MersenneTwisters.MT19937\n \n \nType\n.\n\n\nMT19937\n \n:\n \nMersenneTwister\n{\nUInt32\n}\n\n\nMT19937\n([\nseed\n])\n\n\n\n\n\n\nMT19937 RNG. The \nseed\n is a \nTuple\n of 624 \nUInt32\n numbers, or an \nInteger\n which will be automatically convert to an \nUInt32\n number.\n\n\nsource\n\n\n\n\nInternal\n\n\n#\n\n\nRNG.MersenneTwisters.MersenneTwister\n \n \nType\n.\n\n\nMersenneTwister\n{\nT\n}\n \n:\n \nRNG\n.\nAbstractRNG\n{\nT\n}\n\n\n\n\n\n\nThe base type of Mersenne Twisters.\n\n\nsource\n\n\n#\n\n\nRNG.MersenneTwisters.mt_get\n \n \nMethod\n.\n\n\nGet a random \nUInt32\n number from a \nMT19937\n object.\n\n\nsource\n\n\n#\n\n\nRNG.MersenneTwisters.mt_set!\n \n \nMethod\n.\n\n\nSet up a \nMT19937\n RNG object using a \nTuple\n of 624 \nUInt32\n numbers.\n\n\nsource\n\n\n#\n\n\nRNG.MersenneTwisters.mt_set!\n \n \nMethod\n.\n\n\nSet up a \nMT19937\n RNG object using an \nUInt32\n number.\n\n\nsource", 
            "title": "MersenneTwisters"
        }, 
        {
            "location": "/lib/mersenne-twisters/#mersennetwisters", 
            "text": "", 
            "title": "MersenneTwisters"
        }, 
        {
            "location": "/lib/mersenne-twisters/#index", 
            "text": "RNG.MersenneTwisters  RNG.MersenneTwisters.MT19937  RNG.MersenneTwisters.MersenneTwister  RNG.MersenneTwisters.mt_get  RNG.MersenneTwisters.mt_set!  RNG.MersenneTwisters.mt_set!", 
            "title": "Index"
        }, 
        {
            "location": "/lib/mersenne-twisters/#public", 
            "text": "#  RNG.MersenneTwisters     Module .  The module for  Mersenne Twisters .  Currently only provide one RNG type:   MT19937   source  #  RNG.MersenneTwisters.MT19937     Type .  MT19937   :   MersenneTwister { UInt32 }  MT19937 ([ seed ])   MT19937 RNG. The  seed  is a  Tuple  of 624  UInt32  numbers, or an  Integer  which will be automatically convert to an  UInt32  number.  source", 
            "title": "Public"
        }, 
        {
            "location": "/lib/mersenne-twisters/#internal", 
            "text": "#  RNG.MersenneTwisters.MersenneTwister     Type .  MersenneTwister { T }   :   RNG . AbstractRNG { T }   The base type of Mersenne Twisters.  source  #  RNG.MersenneTwisters.mt_get     Method .  Get a random  UInt32  number from a  MT19937  object.  source  #  RNG.MersenneTwisters.mt_set!     Method .  Set up a  MT19937  RNG object using a  Tuple  of 624  UInt32  numbers.  source  #  RNG.MersenneTwisters.mt_set!     Method .  Set up a  MT19937  RNG object using an  UInt32  number.  source", 
            "title": "Internal"
        }, 
        {
            "location": "/lib/random123/", 
            "text": "Random123\n\n\n\n\nIndex\n\n\n\n\nRNG.Random123\n\n\nRNG.Random123.R123_USE_AESNI\n\n\nRNG.Random123.AESNI1x\n\n\nRNG.Random123.AESNI4x\n\n\nRNG.Random123.AESNIKey\n\n\nRNG.Random123.ARS1x\n\n\nRNG.Random123.ARS4x\n\n\nRNG.Random123.AbstractR123\n\n\nRNG.Random123.Philox2x\n\n\nRNG.Random123.Philox4x\n\n\nRNG.Random123.R123Generator1x\n\n\nRNG.Random123.R123Generator2x\n\n\nRNG.Random123.R123Generator4x\n\n\nRNG.Random123.Threefry2x\n\n\nRNG.Random123.Threefry4x\n\n\nRNG.Random123.random123_r\n\n\nRNG.Random123.set_counter!\n\n\n\n\n\n\nPublic\n\n\n#\n\n\nRNG.Random123\n \n \nModule\n.\n\n\nThe module for \nRandom123 Family\n.\n\n\nProvide 8 RNG types:\n\n\n\n\nThreefry2x\n\n\nThreefry4x\n\n\nPhilox2x\n\n\nPhilox4x\n\n\nAESNI1x\n\n\nAESNI4x\n\n\nARS1x\n\n\nARS4x\n\n\n\n\nsource\n\n\n#\n\n\nRNG.Random123.R123_USE_AESNI\n \n \nConstant\n.\n\n\nTrue when AES-NI library has been compiled.\n\n\nsource\n\n\n#\n\n\nRNG.Random123.AESNI1x\n \n \nType\n.\n\n\nAESNI1x\n \n:\n \nR123Generator1x\n{\nUInt128\n}\n\n\nAESNI1x\n([\nseed\n])\n\n\n\n\n\n\nAESNI1x is one kind of AESNI Counter-Based RNGs. It generates one \nUInt128\n number at a time.\n\n\nseed\n is an \nInteger\n which will be automatically converted to \nUInt128\n.\n\n\nOnly available when \nR123_USE_AESNI\n.\n\n\nsource\n\n\n#\n\n\nRNG.Random123.AESNI4x\n \n \nType\n.\n\n\nAESNI4x\n \n:\n \nR123Generator4x\n{\nUInt32\n}\n\n\nAESNI4x\n([\nseed\n])\n\n\n\n\n\n\nAESNI4x is one kind of AESNI Counter-Based RNGs. It generates four \nUInt32\n numbers at a time.\n\n\nseed\n is a \nTuple\n of four \nInteger\ns which will all be automatically converted to \nUInt32\n.\n\n\nOnly available when \nR123_USE_AESNI\n.\n\n\nsource\n\n\n#\n\n\nRNG.Random123.ARS1x\n \n \nType\n.\n\n\nARS1x\n{\nR\n}\n \n:\n \nR123Generator1x\n{\nUInt128\n}\n\n\nARS1x\n([\nseed\n,\n \nR\n=\n7\n])\n\n\n\n\n\n\nARS1x is one kind of ARS Counter-Based RNGs. It generates one \nUInt128\n number at a time.\n\n\nseed\n is an \nInteger\n which will be automatically converted to \nUInt128\n.\n\n\nR\n denotes to the Rounds which should be at least 1 and no more than 10. With 7 rounds (by default), it has a considerable safety margin over the minimum number of rounds with no known statistical flaws, but still has excellent performance.\n\n\nOnly available when \nR123_USE_AESNI\n.\n\n\nsource\n\n\n#\n\n\nRNG.Random123.ARS4x\n \n \nType\n.\n\n\nARS4x\n{\nR\n}\n \n:\n \nR123Generator4x\n{\nUInt32\n}\n\n\nARS4x\n([\nseed\n,\n \nR\n=\n7\n])\n\n\n\n\n\n\nARS4x is one kind of ARS Counter-Based RNGs. It generates four \nUInt32\n numbers at a time.\n\n\nseed\n is a \nTuple\n of four \nInteger\ns which will all be automatically converted to \nUInt32\n.\n\n\nR\n denotes to the Rounds which must be at least 1 and no more than 10. With 7 rounds (by default), it has a considerable safety margin over the minimum number of rounds with no known statistical flaws, but still has excellent performance.\n\n\nOnly available when \nR123_USE_AESNI\n.\n\n\nsource\n\n\n#\n\n\nRNG.Random123.Philox2x\n \n \nType\n.\n\n\nPhilox2x\n{\nT\n,\n \nR\n}\n \n:\n \nR123Generator2x\n{\nT\n}\n\n\nPhilox2x\n([\nseed\n,\n \nR\n])\n\n\nPhilox2x\n(\nT\n[,\n \nseed\n,\n \nR\n])\n\n\n\n\n\n\nPhilox2x is one kind of Philox Counter-Based RNGs. It generates two numbers at a time.\n\n\nT\n is \nUInt32\n or \nUInt64\n(default).\n\n\nseed\n is an \nInteger\n which will be automatically converted to \nT\n.\n\n\nR\n denotes to the Rounds which must be at least 1 and no more than 16. With 10 rounds (by default), it has a considerable safety margin over the minimum number of rounds with no known statistical flaws, but still has excellent performance.\n\n\nsource\n\n\n#\n\n\nRNG.Random123.Philox4x\n \n \nType\n.\n\n\nPhilox4x\n{\nT\n,\n \nR\n}\n \n:\n \nR123Generator4x\n{\nT\n}\n\n\nPhilox4x\n([\nseed\n,\n \nR\n])\n\n\nPhilox4x\n(\nT\n[,\n \nseed\n,\n \nR\n])\n\n\n\n\n\n\nPhilox4x is one kind of Philox Counter-Based RNGs. It generates four numbers at a time.\n\n\nT\n is \nUInt32\n or \nUInt64\n(default).\n\n\nseed\n is a \nTuple\n of two \nInteger\ns which will both be automatically converted to \nT\n.\n\n\nR\n denotes to the Rounds which must be at least 1 and no more than 16. With 10 rounds (by default), it has a considerable safety margin over the minimum number of rounds with no known statistical flaws, but still has excellent performance.\n\n\nsource\n\n\n#\n\n\nRNG.Random123.Threefry2x\n \n \nType\n.\n\n\nThreefry2x\n{\nT\n,\n \nR\n}\n \n:\n \nR123Generator2x\n{\nT\n}\n\n\nThreefry2x\n([\nseed\n,\n \nR\n])\n\n\nThreefry2x\n(\nT\n[,\n \nseed\n,\n \nR\n])\n\n\n\n\n\n\nThreefry2x is one kind of Threefry Counter-Based RNGs. It generates two numbers at a time.\n\n\nT\n is \nUInt32\n or \nUInt64\n(default).\n\n\nseed\n is a \nTuple\n of two \nInteger\ns which will both be automatically converted to \nT\n.\n\n\nR\n denotes to the Rounds which must be at least 1 and no more than 32. With 20 rounds (by default), it has a considerable safety margin over the minimum number of rounds with no known statistical flaws, but still has excellent performance.\n\n\nsource\n\n\n#\n\n\nRNG.Random123.Threefry4x\n \n \nType\n.\n\n\nThreefry4x\n{\nT\n,\n \nR\n}\n \n:\n \nR123Generator4x\n{\nT\n}\n\n\nThreefry4x\n([\nseed\n,\n \nR\n])\n\n\nThreefry4x\n(\nT\n[,\n \nseed\n,\n \nR\n])\n\n\n\n\n\n\nThreefry2x is one kind of Threefry Counter-Based RNGs. It generates four numbers at a time.\n\n\nT\n is \nUInt32\n or \nUInt64\n(default).\n\n\nseed\n is a \nTuple\n of four \nInteger\ns which will all be automatically converted to \nT\n.\n\n\nR\n denotes to the Rounds which must be at least 1 and no more than 32. With 20 rounds (by default), it has a considerable safety margin over the minimum number of rounds with no known statistical flaws, but still has excellent performance.\n\n\nsource\n\n\n#\n\n\nRNG.Random123.set_counter!\n \n \nMethod\n.\n\n\nSet the counter of a Random123 RNG.\n\n\nsource\n\n\n\n\nInternal\n\n\n#\n\n\nRNG.Random123.AESNIKey\n \n \nType\n.\n\n\nThe key for AESNI.\n\n\nsource\n\n\n#\n\n\nRNG.Random123.AbstractR123\n \n \nType\n.\n\n\nThe base abstract type for RNGs in \nRandom123 Family\n.\n\n\nsource\n\n\n#\n\n\nRNG.Random123.R123Generator1x\n \n \nType\n.\n\n\nRNG that generates one number at a time.\n\n\nsource\n\n\n#\n\n\nRNG.Random123.R123Generator2x\n \n \nType\n.\n\n\nRNG that generates two numbers at a time.\n\n\nsource\n\n\n#\n\n\nRNG.Random123.R123Generator4x\n \n \nType\n.\n\n\nRNG that generates four numbers at a time.\n\n\nsource\n\n\n#\n\n\nRNG.Random123.random123_r\n \n \nFunction\n.\n\n\nDo one iteration and return the a tuple of a Random123 RNG object.\n\n\nsource", 
            "title": "Random123"
        }, 
        {
            "location": "/lib/random123/#random123", 
            "text": "", 
            "title": "Random123"
        }, 
        {
            "location": "/lib/random123/#index", 
            "text": "RNG.Random123  RNG.Random123.R123_USE_AESNI  RNG.Random123.AESNI1x  RNG.Random123.AESNI4x  RNG.Random123.AESNIKey  RNG.Random123.ARS1x  RNG.Random123.ARS4x  RNG.Random123.AbstractR123  RNG.Random123.Philox2x  RNG.Random123.Philox4x  RNG.Random123.R123Generator1x  RNG.Random123.R123Generator2x  RNG.Random123.R123Generator4x  RNG.Random123.Threefry2x  RNG.Random123.Threefry4x  RNG.Random123.random123_r  RNG.Random123.set_counter!", 
            "title": "Index"
        }, 
        {
            "location": "/lib/random123/#public", 
            "text": "#  RNG.Random123     Module .  The module for  Random123 Family .  Provide 8 RNG types:   Threefry2x  Threefry4x  Philox2x  Philox4x  AESNI1x  AESNI4x  ARS1x  ARS4x   source  #  RNG.Random123.R123_USE_AESNI     Constant .  True when AES-NI library has been compiled.  source  #  RNG.Random123.AESNI1x     Type .  AESNI1x   :   R123Generator1x { UInt128 }  AESNI1x ([ seed ])   AESNI1x is one kind of AESNI Counter-Based RNGs. It generates one  UInt128  number at a time.  seed  is an  Integer  which will be automatically converted to  UInt128 .  Only available when  R123_USE_AESNI .  source  #  RNG.Random123.AESNI4x     Type .  AESNI4x   :   R123Generator4x { UInt32 }  AESNI4x ([ seed ])   AESNI4x is one kind of AESNI Counter-Based RNGs. It generates four  UInt32  numbers at a time.  seed  is a  Tuple  of four  Integer s which will all be automatically converted to  UInt32 .  Only available when  R123_USE_AESNI .  source  #  RNG.Random123.ARS1x     Type .  ARS1x { R }   :   R123Generator1x { UInt128 }  ARS1x ([ seed ,   R = 7 ])   ARS1x is one kind of ARS Counter-Based RNGs. It generates one  UInt128  number at a time.  seed  is an  Integer  which will be automatically converted to  UInt128 .  R  denotes to the Rounds which should be at least 1 and no more than 10. With 7 rounds (by default), it has a considerable safety margin over the minimum number of rounds with no known statistical flaws, but still has excellent performance.  Only available when  R123_USE_AESNI .  source  #  RNG.Random123.ARS4x     Type .  ARS4x { R }   :   R123Generator4x { UInt32 }  ARS4x ([ seed ,   R = 7 ])   ARS4x is one kind of ARS Counter-Based RNGs. It generates four  UInt32  numbers at a time.  seed  is a  Tuple  of four  Integer s which will all be automatically converted to  UInt32 .  R  denotes to the Rounds which must be at least 1 and no more than 10. With 7 rounds (by default), it has a considerable safety margin over the minimum number of rounds with no known statistical flaws, but still has excellent performance.  Only available when  R123_USE_AESNI .  source  #  RNG.Random123.Philox2x     Type .  Philox2x { T ,   R }   :   R123Generator2x { T }  Philox2x ([ seed ,   R ])  Philox2x ( T [,   seed ,   R ])   Philox2x is one kind of Philox Counter-Based RNGs. It generates two numbers at a time.  T  is  UInt32  or  UInt64 (default).  seed  is an  Integer  which will be automatically converted to  T .  R  denotes to the Rounds which must be at least 1 and no more than 16. With 10 rounds (by default), it has a considerable safety margin over the minimum number of rounds with no known statistical flaws, but still has excellent performance.  source  #  RNG.Random123.Philox4x     Type .  Philox4x { T ,   R }   :   R123Generator4x { T }  Philox4x ([ seed ,   R ])  Philox4x ( T [,   seed ,   R ])   Philox4x is one kind of Philox Counter-Based RNGs. It generates four numbers at a time.  T  is  UInt32  or  UInt64 (default).  seed  is a  Tuple  of two  Integer s which will both be automatically converted to  T .  R  denotes to the Rounds which must be at least 1 and no more than 16. With 10 rounds (by default), it has a considerable safety margin over the minimum number of rounds with no known statistical flaws, but still has excellent performance.  source  #  RNG.Random123.Threefry2x     Type .  Threefry2x { T ,   R }   :   R123Generator2x { T }  Threefry2x ([ seed ,   R ])  Threefry2x ( T [,   seed ,   R ])   Threefry2x is one kind of Threefry Counter-Based RNGs. It generates two numbers at a time.  T  is  UInt32  or  UInt64 (default).  seed  is a  Tuple  of two  Integer s which will both be automatically converted to  T .  R  denotes to the Rounds which must be at least 1 and no more than 32. With 20 rounds (by default), it has a considerable safety margin over the minimum number of rounds with no known statistical flaws, but still has excellent performance.  source  #  RNG.Random123.Threefry4x     Type .  Threefry4x { T ,   R }   :   R123Generator4x { T }  Threefry4x ([ seed ,   R ])  Threefry4x ( T [,   seed ,   R ])   Threefry2x is one kind of Threefry Counter-Based RNGs. It generates four numbers at a time.  T  is  UInt32  or  UInt64 (default).  seed  is a  Tuple  of four  Integer s which will all be automatically converted to  T .  R  denotes to the Rounds which must be at least 1 and no more than 32. With 20 rounds (by default), it has a considerable safety margin over the minimum number of rounds with no known statistical flaws, but still has excellent performance.  source  #  RNG.Random123.set_counter!     Method .  Set the counter of a Random123 RNG.  source", 
            "title": "Public"
        }, 
        {
            "location": "/lib/random123/#internal", 
            "text": "#  RNG.Random123.AESNIKey     Type .  The key for AESNI.  source  #  RNG.Random123.AbstractR123     Type .  The base abstract type for RNGs in  Random123 Family .  source  #  RNG.Random123.R123Generator1x     Type .  RNG that generates one number at a time.  source  #  RNG.Random123.R123Generator2x     Type .  RNG that generates two numbers at a time.  source  #  RNG.Random123.R123Generator4x     Type .  RNG that generates four numbers at a time.  source  #  RNG.Random123.random123_r     Function .  Do one iteration and return the a tuple of a Random123 RNG object.  source", 
            "title": "Internal"
        }, 
        {
            "location": "/lib/xorshifts/", 
            "text": "Xorshifts\n\n\n\n\nIndex\n\n\n\n\nRNG.Xorshifts\n\n\nRNG.Xorshifts.AbstractXoroshiro128\n\n\nRNG.Xorshifts.AbstractXorshift1024\n\n\nRNG.Xorshifts.AbstractXorshift128\n\n\nRNG.Xorshifts.AbstractXorshift64\n\n\nRNG.Xorshifts.Xoroshiro128\n\n\nRNG.Xorshifts.Xoroshiro128Plus\n\n\nRNG.Xorshifts.Xoroshiro128Star\n\n\nRNG.Xorshifts.Xorshift1024\n\n\nRNG.Xorshifts.Xorshift1024Plus\n\n\nRNG.Xorshifts.Xorshift1024Star\n\n\nRNG.Xorshifts.Xorshift128\n\n\nRNG.Xorshifts.Xorshift128Plus\n\n\nRNG.Xorshifts.Xorshift128Star\n\n\nRNG.Xorshifts.Xorshift64\n\n\nRNG.Xorshifts.Xorshift64Star\n\n\nRNG.Xorshifts.xorshift_next\n\n\n\n\n\n\nPublic\n\n\n#\n\n\nRNG.Xorshifts\n \n \nModule\n.\n\n\nThe module for \nXorshift Family\n.\n\n\nProvide 11 RNG types:\n\n\n\n\nXorshift64\n\n\nXorshift64Star\n\n\nXorshift128\n\n\nXorshift128Star\n\n\nXorshift128Plus\n\n\nXorshift1024\n\n\nXorshift1024Star\n\n\nXorshift1024Plus\n\n\nXoroshiro128\n\n\nXoroshiro128Star\n\n\nXoroshiro128Plus\n\n\n\n\nsource\n\n\n#\n\n\nRNG.Xorshifts.Xoroshiro128\n \n \nType\n.\n\n\nXoroshiro128\n \n:\n \nAbstractXoroshiro128\n\n\nXoroshiro128\n([\nseed\n])\n\n\n\n\n\n\nXoroshiro128 RNG. The \nseed\n can be a \nTuple\n of two \nUInt64\ns, or an \nInteger\n which will be automatically convert to an \nUInt128\n number.\n\n\nsource\n\n\n#\n\n\nRNG.Xorshifts.Xoroshiro128Plus\n \n \nType\n.\n\n\nXoroshiro128Plus\n \n:\n \nAbstractXoroshiro128\n\n\nXoroshiro128Plus\n([\nseed\n])\n\n\n\n\n\n\nXoroshiro128Plus RNG. The \nseed\n can be a \nTuple\n of two \nUInt64\ns, or an \nInteger\n which will be automatically convert to an \nUInt128\n number.\n\n\nsource\n\n\n#\n\n\nRNG.Xorshifts.Xoroshiro128Star\n \n \nType\n.\n\n\nXoroshiro128Star\n \n:\n \nAbstractXoroshiro128\n\n\nXoroshiro128Star\n([\nseed\n])\n\n\n\n\n\n\nXoroshiro128Star RNG. The \nseed\n can be a \nTuple\n of two \nUInt64\ns, or an \nInteger\n which will be automatically convert to an \nUInt128\n number.\n\n\nsource\n\n\n#\n\n\nRNG.Xorshifts.Xorshift1024\n \n \nType\n.\n\n\nXorshift1024\n \n:\n \nAbstractXorshift1024\n\n\nXorshift1024\n([\nseed\n...\n])\n\n\n\n\n\n\nXorshift1024 RNG. The \nseed\n can be a \nTuple\n of 16 \nUInt64\ns, or several (no more than 16) \nInteger\ns which will all be automatically converted to \nUInt64\n numbers.\n\n\nsource\n\n\n#\n\n\nRNG.Xorshifts.Xorshift1024Plus\n \n \nType\n.\n\n\nXorshift1024Plus\n \n:\n \nAbstractXorshift1024\n\n\nXorshift1024Plus\n([\nseed\n...\n])\n\n\n\n\n\n\nXorshift1024Plus RNG. The \nseed\n can be a \nTuple\n of 16 \nUInt64\ns, or several (no more than 16) \nInteger\ns which will all be automatically converted to \nUInt64\n numbers.\n\n\nsource\n\n\n#\n\n\nRNG.Xorshifts.Xorshift1024Star\n \n \nType\n.\n\n\nXorshift1024Star\n \n:\n \nAbstractXorshift1024\n\n\nXorshift1024Star\n([\nseed\n...\n])\n\n\n\n\n\n\nXorshift1024Star RNG. The \nseed\n can be a \nTuple\n of 16 \nUInt64\ns, or several (no more than 16) \nInteger\ns which will all be automatically converted to \nUInt64\n numbers.\n\n\nsource\n\n\n#\n\n\nRNG.Xorshifts.Xorshift128\n \n \nType\n.\n\n\nXorshift128\n \n:\n \nAbstractXorshift128\n\n\nXorshift128\n([\nseed\n])\n\n\n\n\n\n\nXorshift128 RNG. The \nseed\n can be a \nTuple\n of two \nUInt64\ns, or an \nInteger\n which will be automatically convert to an \nUInt128\n number.\n\n\nsource\n\n\n#\n\n\nRNG.Xorshifts.Xorshift128Plus\n \n \nType\n.\n\n\nXorshift128Plus\n \n:\n \nAbstractXorshift128\n\n\nXorshift128Plus\n([\nseed\n])\n\n\n\n\n\n\nXorshift128Plus RNG. The \nseed\n can be a \nTuple\n of two \nUInt64\ns, or an \nInteger\n which will be automatically convert to an \nUInt128\n number.\n\n\nsource\n\n\n#\n\n\nRNG.Xorshifts.Xorshift128Star\n \n \nType\n.\n\n\nXorshift128Star\n \n:\n \nAbstractXorshift128\n\n\nXorshift128Star\n([\nseed\n])\n\n\n\n\n\n\nXorshift128Star RNG. The \nseed\n can be a \nTuple\n of two \nUInt64\ns, or an \nInteger\n which will be automatically convert to an \nUInt128\n number.\n\n\nsource\n\n\n#\n\n\nRNG.Xorshifts.Xorshift64\n \n \nType\n.\n\n\nXorshift64\n \n:\n \nAbstractXorshift64\n\n\nXorshift64\n([\nseed\n])\n\n\n\n\n\n\nXorshift64 RNG. The \nseed\n will be automatically convert to an \nUInt64\n number.\n\n\nsource\n\n\n#\n\n\nRNG.Xorshifts.Xorshift64Star\n \n \nType\n.\n\n\nXorshift64Star\n \n:\n \nAbstractXorshift64\n\n\nXorshift64Star\n([\nseed\n])\n\n\n\n\n\n\nXorshift64Star RNG. The \nseed\n will be automatically convert to an \nUInt64\n number.\n\n\nsource\n\n\n\n\nInternal\n\n\n#\n\n\nRNG.Xorshifts.AbstractXoroshiro128\n \n \nType\n.\n\n\nAbstractXoroshiro128\n \n:\n \nAbstractRNG\n{\nUInt64\n}\n\n\n\n\n\n\nThe base abstract type for \nXoroshiro128\n, \nXoroshiro128Star\n and \nXoroshiro128Plus\n.\n\n\nsource\n\n\n#\n\n\nRNG.Xorshifts.AbstractXorshift1024\n \n \nType\n.\n\n\nAbstractXorshift1024\n \n:\n \nAbstractRNG\n{\nUInt64\n}\n\n\n\n\n\n\nThe base abstract type for \nXorshift1024\n, \nXorshift1024Star\n and \nXorshift1024Plus\n.\n\n\nsource\n\n\n#\n\n\nRNG.Xorshifts.AbstractXorshift128\n \n \nType\n.\n\n\nAbstractXorshift128\n \n:\n \nAbstractRNG\n{\nUInt64\n}\n\n\n\n\n\n\nThe base abstract type for \nXorshift128\n, \nXorshift128Star\n and \nXorshift128Plus\n.\n\n\nsource\n\n\n#\n\n\nRNG.Xorshifts.AbstractXorshift64\n \n \nType\n.\n\n\nAbstractXorshift64\n \n:\n \nAbstractRNG\n{\nUInt64\n}\n\n\n\n\n\n\nThe base abstract type for \nXorshift64\n and \nXorshift64Star\n.\n\n\nsource\n\n\n#\n\n\nRNG.Xorshifts.xorshift_next\n \n \nFunction\n.\n\n\nDo one iteration and get the current value of a Xorshift RNG object.\n\n\nsource", 
            "title": "Xorshifts"
        }, 
        {
            "location": "/lib/xorshifts/#xorshifts", 
            "text": "", 
            "title": "Xorshifts"
        }, 
        {
            "location": "/lib/xorshifts/#index", 
            "text": "RNG.Xorshifts  RNG.Xorshifts.AbstractXoroshiro128  RNG.Xorshifts.AbstractXorshift1024  RNG.Xorshifts.AbstractXorshift128  RNG.Xorshifts.AbstractXorshift64  RNG.Xorshifts.Xoroshiro128  RNG.Xorshifts.Xoroshiro128Plus  RNG.Xorshifts.Xoroshiro128Star  RNG.Xorshifts.Xorshift1024  RNG.Xorshifts.Xorshift1024Plus  RNG.Xorshifts.Xorshift1024Star  RNG.Xorshifts.Xorshift128  RNG.Xorshifts.Xorshift128Plus  RNG.Xorshifts.Xorshift128Star  RNG.Xorshifts.Xorshift64  RNG.Xorshifts.Xorshift64Star  RNG.Xorshifts.xorshift_next", 
            "title": "Index"
        }, 
        {
            "location": "/lib/xorshifts/#public", 
            "text": "#  RNG.Xorshifts     Module .  The module for  Xorshift Family .  Provide 11 RNG types:   Xorshift64  Xorshift64Star  Xorshift128  Xorshift128Star  Xorshift128Plus  Xorshift1024  Xorshift1024Star  Xorshift1024Plus  Xoroshiro128  Xoroshiro128Star  Xoroshiro128Plus   source  #  RNG.Xorshifts.Xoroshiro128     Type .  Xoroshiro128   :   AbstractXoroshiro128  Xoroshiro128 ([ seed ])   Xoroshiro128 RNG. The  seed  can be a  Tuple  of two  UInt64 s, or an  Integer  which will be automatically convert to an  UInt128  number.  source  #  RNG.Xorshifts.Xoroshiro128Plus     Type .  Xoroshiro128Plus   :   AbstractXoroshiro128  Xoroshiro128Plus ([ seed ])   Xoroshiro128Plus RNG. The  seed  can be a  Tuple  of two  UInt64 s, or an  Integer  which will be automatically convert to an  UInt128  number.  source  #  RNG.Xorshifts.Xoroshiro128Star     Type .  Xoroshiro128Star   :   AbstractXoroshiro128  Xoroshiro128Star ([ seed ])   Xoroshiro128Star RNG. The  seed  can be a  Tuple  of two  UInt64 s, or an  Integer  which will be automatically convert to an  UInt128  number.  source  #  RNG.Xorshifts.Xorshift1024     Type .  Xorshift1024   :   AbstractXorshift1024  Xorshift1024 ([ seed ... ])   Xorshift1024 RNG. The  seed  can be a  Tuple  of 16  UInt64 s, or several (no more than 16)  Integer s which will all be automatically converted to  UInt64  numbers.  source  #  RNG.Xorshifts.Xorshift1024Plus     Type .  Xorshift1024Plus   :   AbstractXorshift1024  Xorshift1024Plus ([ seed ... ])   Xorshift1024Plus RNG. The  seed  can be a  Tuple  of 16  UInt64 s, or several (no more than 16)  Integer s which will all be automatically converted to  UInt64  numbers.  source  #  RNG.Xorshifts.Xorshift1024Star     Type .  Xorshift1024Star   :   AbstractXorshift1024  Xorshift1024Star ([ seed ... ])   Xorshift1024Star RNG. The  seed  can be a  Tuple  of 16  UInt64 s, or several (no more than 16)  Integer s which will all be automatically converted to  UInt64  numbers.  source  #  RNG.Xorshifts.Xorshift128     Type .  Xorshift128   :   AbstractXorshift128  Xorshift128 ([ seed ])   Xorshift128 RNG. The  seed  can be a  Tuple  of two  UInt64 s, or an  Integer  which will be automatically convert to an  UInt128  number.  source  #  RNG.Xorshifts.Xorshift128Plus     Type .  Xorshift128Plus   :   AbstractXorshift128  Xorshift128Plus ([ seed ])   Xorshift128Plus RNG. The  seed  can be a  Tuple  of two  UInt64 s, or an  Integer  which will be automatically convert to an  UInt128  number.  source  #  RNG.Xorshifts.Xorshift128Star     Type .  Xorshift128Star   :   AbstractXorshift128  Xorshift128Star ([ seed ])   Xorshift128Star RNG. The  seed  can be a  Tuple  of two  UInt64 s, or an  Integer  which will be automatically convert to an  UInt128  number.  source  #  RNG.Xorshifts.Xorshift64     Type .  Xorshift64   :   AbstractXorshift64  Xorshift64 ([ seed ])   Xorshift64 RNG. The  seed  will be automatically convert to an  UInt64  number.  source  #  RNG.Xorshifts.Xorshift64Star     Type .  Xorshift64Star   :   AbstractXorshift64  Xorshift64Star ([ seed ])   Xorshift64Star RNG. The  seed  will be automatically convert to an  UInt64  number.  source", 
            "title": "Public"
        }, 
        {
            "location": "/lib/xorshifts/#internal", 
            "text": "#  RNG.Xorshifts.AbstractXoroshiro128     Type .  AbstractXoroshiro128   :   AbstractRNG { UInt64 }   The base abstract type for  Xoroshiro128 ,  Xoroshiro128Star  and  Xoroshiro128Plus .  source  #  RNG.Xorshifts.AbstractXorshift1024     Type .  AbstractXorshift1024   :   AbstractRNG { UInt64 }   The base abstract type for  Xorshift1024 ,  Xorshift1024Star  and  Xorshift1024Plus .  source  #  RNG.Xorshifts.AbstractXorshift128     Type .  AbstractXorshift128   :   AbstractRNG { UInt64 }   The base abstract type for  Xorshift128 ,  Xorshift128Star  and  Xorshift128Plus .  source  #  RNG.Xorshifts.AbstractXorshift64     Type .  AbstractXorshift64   :   AbstractRNG { UInt64 }   The base abstract type for  Xorshift64  and  Xorshift64Star .  source  #  RNG.Xorshifts.xorshift_next     Function .  Do one iteration and get the current value of a Xorshift RNG object.  source", 
            "title": "Internal"
        }
    ]
}